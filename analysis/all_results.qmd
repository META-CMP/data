---
title: "Analysis and results of the research project “Do monetary policy shocks aﬀect output, employment, and prices? Meta-analyses on the eﬀects of conventional monetary policy”"
author: "Matthias Enzinger, Sebastian Gechert, Philipp Heimberger, Franz Prante, Daniel F. Romero"
date: last-modified
date-format: full
execute:
  message: false
  warning: false
format: 
  html:
    toc: true
    toc-depth: 5
---

::: {.callout-note}
# About this document

Here we collect all the relevant results of our research project in a reproducible form. This document can also serve as the general research report in which we document all our analysis steps connected to our pre-registration. In this regard, we should indicate which analyses are connected to our original hypotheses (H1-H9) and which analyses are of "exploratory" nature. Where relevant, we should also state where we deviated from our pre-analysis plan and provide the reasons. For specific research papers and journal submissions, we can then choose the results that we want to present in the papers.

:::


::: {.callout-important}
## TO DO: Confirmatory and exploratory analyses, pre-reg deviations.

- Connect H1-H9 and mark exploratory analyses.
- State and justify pre-reg deviations.

:::

# Preparation

::: {.callout-note}

We do the following in the preparation

- load libraries
- load data
- load our own functions (including Kasy functions)
- define the function to extract corrected IRFs from estimations __(TO DO: we should define this function externally and source it too)__
- filter out models with quality concerns
- specify periods to estimate for `chosen_periods`
- define global winsorization parameter `wins_para`
- set a global confidence interval level for regression tables `conflevel`
:::

::: {.callout-important}
## TO DO: Reporting of full sample results for transparency

We would somewhere need to justify why we only look at studies without quality_concern, these specific periods, this winsorization level and also provide the results for the full dataset. For the html version, we could do this in collapsable callout blocks.
:::

```{r prep}
# Load libraries
library(here)
library(tidyverse) # for data manipulation
library(dplyr) # for data manipulation
library(modelsummary) # to nicely print results
library(plotly)
library(JWileymisc)
library(viridis) # Color palette used in funnel
library(fastDummies) # Automatic dummy creation
library(BMS) # Bayesian model averaging

# Load our functions
source(here("analysis/R/plot_mean_effect.R"))
source(here("analysis/R/apply_winsorization.R"))
source(here("analysis/R/plot_average_irfs.R"))
source(here("analysis/R/funnel_plot.R"))
source(here("analysis/R/display_equation.R"))
source(here("analysis/R/meta_analysis.R"))
# Function to extract intercept estimates (corrected IRF) # TO DO: Define this externally
extract_intercepts <- function(model, method) {
  if (method == "AK") {
    estimate <- model$tidy[1, 2]
    se <- model$tidy[1, 3]
    ci_lower <- estimate - se * qnorm(1 - (1 - conflevel) / 2)
    ci_upper <- estimate + se * qnorm(1 - (1 - conflevel) / 2)
  } else {
    ci <- confint(model, level = conflevel)
    estimate <- unname(coef(model)[1])
    ci_lower <- unname(ci[1, 1])
    ci_upper <- unname(ci[1, 2])
  }
  return(c(estimate = estimate, lower = ci_lower, upper = ci_upper))
}
# Load AK functions
source(here("analysis/R/kasy_MetaStudiesFunctions.R"))
source(here("analysis/R/kasy_RobustVariance.R"))
source(here("analysis/R/kasy_MetaStudiesPlots.R"))

# Load data
data_path <- here("data/preliminary_data_test.RData") # works
load(data_path)

# Filter out models with quality concerns
data_with_quality_concern <- data # First, store data with quality concerns for access
data <- data %>% filter(quality_concern!=1)

# Specify periods to estimate for
chosen_periods <- c(seq(3, 60, by = 3))

# Define global winsorization parameter
wins_para <- 0.02

# Set a global confidence interval level for regression tables
conflevel <- 0.89

```


# Overall effects

## Basic data plots

These plots show the IRF data points from the selected primary studies, with colors indicating the details on the definition of the outcome variable.

::: {.callout-important}
### TO DOs: 

- Plot median and mean line in these plots. 
- Show winsorized versions of the plots, maybe next to each other 
:::

### Output
```{r basic_plot_output}
out_var <- "output"
plot_mean_effect(data %>% filter(outcome == out_var), 
                 filter_outcome = out_var, 
                 x_axis = "period_month")
```

### Price level 
```{r basic_plot_pricelevel}
out_var <- "inflation"
plot_mean_effect(data %>% filter(outcome == out_var), 
                 filter_outcome = out_var, 
                 x_axis = "period_month")
```

### (Un)employment 
#### Unemployment rate
```{r basic_plot_unemp}
out_var <- "unemp"
plot_mean_effect(data %>% filter(outcome == out_var), 
                 filter_outcome = out_var, 
                 x_axis = "period_month")
```
#### Employment
```{r basic_plot_emp}
out_var <- "emp"
plot_mean_effect(data %>% filter(outcome == out_var), 
                 filter_outcome = out_var, x_axis = "period_month")
```

### Interest rate 
```{r basic_plot_rate}
out_var <- "rate"
plot_mean_effect(data %>% filter(outcome == out_var), 
                 filter_outcome = out_var, x_axis = "period_month")

# Add mean line 
```

## Average IRFs

::: {.callout-important}
### TO DO: Median line

Plot median line in these plots. 
:::

::: {.callout-important}
### TO DO: Maybe explore subsample average IRFs?

- High quality-only sample?
- identifcation procedures
- top journals
- ...

:::


::: {.callout-important}
### TO DO: What are the findings with respect to H1?
:::

### Output
```{r avg_irf_output}

out_var <- "output"

# Without median 
avg_irf_output <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE,
  show_median = FALSE
)

# With median 
avg_irf_output_median <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE,
  show_median = TRUE
)

avg_irf_output_median 

```

### Price level 
```{r avg_irf_pricelevel}

out_var <- "inflation"

avg_irf_pricelevel <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE,
  show_median = FALSE
)

avg_irf_pricelevel_median <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE,
  show_median = TRUE
)

avg_irf_pricelevel_median
```

### (Un)employment
#### Unemployment rate
```{r avg_irf_unemp}

out_var <- "unemp"

avg_irf_unemp <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE,
  show_median = TRUE
)

avg_irf_unemp
```

#### Employment 
```{r avg_irf_emp}

out_var <- "emp"

avg_irf_emp <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE,
  show_median = TRUE
)

avg_irf_emp
```

### Interest rate
```{r avg_irf_rate}

out_var <- "rate"

avg_irf_rate <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE,
  show_median = TRUE
)

avg_irf_rate
```

### All variables

#### With unemployment rate
```{r avg_irf_all_4_unemp}
subplot(avg_irf_output, avg_irf_pricelevel, avg_irf_unemp, avg_irf_rate, nrows = 2, margin = 0.1) %>% layout(
  showlegend=FALSE,
  title = 'Effects of conventional monetary policy',
  xaxis3 = list(title = "Month"), # x-axis for plot 3
  xaxis4 = list(title = "Month")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.2, y = 1, text = "Output", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.8, y = 1, text = "Price level", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.2, y = 0.45, text = "Unemployment rate", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.8, y = 0.45, text = "Interest rate", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom")
),
margin = list(t = 60))
```

#### With employment
```{r avg_irf_all_4_emp}
subplot(avg_irf_output, avg_irf_pricelevel, avg_irf_emp, avg_irf_rate, nrows = 2, margin = 0.1) %>% layout(
  showlegend=FALSE,
  title = 'Effects of conventional monetary policy',
  xaxis3 = list(title = "Month"), # x-axis for plot 3
  xaxis4 = list(title = "Month")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.2, y = 1, text = "Output", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.8, y = 1, text = "Price level", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.2, y = 0.45, text = "Employment", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.8, y = 0.45, text = "Interest rate", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom")
),
margin = list(t = 80))
```

#### With both
```{r avg_irf_all_4}

irf_unemp_emp <- subplot(avg_irf_unemp, avg_irf_emp, nrows = 2, margin = 0.1) %>% layout(
  title = "",
  annotations = list(
    list(x = 0.5, y = 1, text = "Unemployment rate", showarrow = FALSE, xref = "paper", yref = "paper",
         xanchor = "center", yanchor = "bottom"),
    list(x = 0.5, y = 0.4, text = "Employment", showarrow = FALSE, xref = "paper", yref = "paper",
         xanchor = "center", yanchor = "bottom")
),
margin = list(t = 80))

subplot(avg_irf_output, avg_irf_pricelevel, irf_unemp_emp, avg_irf_rate, nrows = 2, margin = 0.1) %>% layout(
  showlegend=FALSE,
  title = 'Effects of conventional monetary policy',
  xaxis4 = list(title = "Month"), # x-axis for plot 3
  xaxis5 = list(title = "Months")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.2, y = 1, text = "Output", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.8, y = 1, text = "Price level", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  # list(x = 0.2, y = 0.45, text = "Unemployment rate", showarrow = FALSE, xref = "paper", yref = "paper",
  #      xanchor = "center", yanchor = "bottom"),
  list(x = 0.8, y = 0.45, text = "Interest rate", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom")
),
margin = list(t = 80))
```

# Publication bias and p-hacking 

## Funnel plots

::: {.callout-important}
### TO DO: What are the findings with respect to H2?
:::

```{r funnel_periods}
periods <- c(1,6,12,18,24,30,36)
opacity <- 0.08
```

### Standard

::: {.callout-important}
#### TO DOs: 

Externally define plotting function for multiple period funnels.

:::

#### Output
```{r funnel_output}

out_var <- "output"

# For single period plot
create_funnel_plot(data %>% filter(outcome == out_var),
                       outvar = out_var,
                       prd = 3,
                       color_by_outcome_var = T,
                       se_option = "avg",
                       wins = wins_para,
                       opac = 0.1,
                       ap = FALSE,
                       type = "standard")


# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     color_by_outcome_var = T,
                     legend = FALSE,
                     se_option = "avg",
                     wins = wins_para,
                     opac = 0.05,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
subplot <- subplot(plot_list, nrows = 7, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "Funnel Plots for Multiple Periods")

# Display the subplot
subplot

```

#### Price level
```{r funnel_pricelevel}
out_var <- "inflation"

# For single period plot
# create_funnel_plot(data %>% filter(outcome == out_var),
#                        outvar = out_var,
#                        prd = 3,
#                        se_option = "avg",
#                        wins = wins_para,
#                        opac = 0.1,
#                        ap = FALSE,
#                        type = "standard")


# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     se_option = "avg",
                     wins = wins_para,
                     opac = 0.05,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
subplot <- subplot(plot_list, nrows = 7, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "Funnel Plots for Multiple Periods")

# Display the subplot
subplot

```

#### (Un)employment
##### Unemployment rate
```{r funnel_unemp}
out_var <- "unemp"
# For single period plot
# create_funnel_plot(data %>% filter(outcome == out_var),
#                        outvar = out_var,
#                        prd = 3,
#                        se_option = "avg",
#                        wins = wins_para,
#                        opac = 0.1,
#                        ap = FALSE,
#                        type = "standard")


# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     se_option = "avg",
                     wins = wins_para,
                     opac = 0.05,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
subplot <- subplot(plot_list, nrows = 7, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "Funnel Plots for Multiple Periods")

# Display the subplot
subplot

```
##### Employment
```{r funnel_emp}
out_var <- "emp"
# For single period plot
# create_funnel_plot(data %>% filter(outcome == out_var),
#                        outvar = out_var,
#                        prd = 3,
#                        se_option = "avg",
#                        wins = wins_para,
#                        opac = 0.1,
#                        ap = FALSE,
#                        type = "standard")


# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     se_option = "avg",
                     wins = wins_para,
                     opac = 0.05,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
subplot <- subplot(plot_list, nrows = 7, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "Funnel Plots for Multiple Periods")

# Display the subplot
subplot

```

#### Interest rate

::: {.callout-tip}
##### Suggestion for a different winsorization level for the interest rate

At the moment, the same global winsorization level is applied to all outcome variables. For the interest rate, the 2 % level is already quite strong (see funnel plots below). We should consider reducing it for the interest rate. 


:::

```{r funnel_rate}
out_var <- "rate"
# For single period plot
# create_funnel_plot(data %>% filter(outcome == out_var),
#                        outvar = out_var,
#                        prd = 3,
#                        se_option = "avg",
#                        wins = wins_para,
#                        opac = 0.1,
#                        ap = FALSE,
#                        type = "standard")


# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     se_option = "avg",
                     wins = wins_para,
                     opac = 0.05,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
subplot <- subplot(plot_list, nrows = 7, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "Funnel Plots for Multiple Periods")

# Display the subplot
subplot

```

### AK style

::: {.callout-important}
#### TO DO 

Maybe add AK style funnel plots.
:::

## Density plots

### Brodeur density plots

::: {.callout-important}
#### TO DO 

Discuss: We need to be aware of the potential impact of measurement or approximation errors, as small errors can easily decide between stat. significant and stat. non-significant results (e.g. extracted effect size 1, SE 1.01, but with error 0.01). Keeping in mind that especially our approximation of the CI bounds is very rough.

Discuss: Using SE.upper instead of SE.avg could be quite important!

- Define functions outside of script
- The option for `counterfact_by_period = TRUE` in the plot function (`create_z_stat_plot()`) doesnt work correctly at the moment. It assigns the wrong df and ncp values to the facet. We use average values instead. This would be nice to have fixed.

:::


```{r brodeur_functions}
# Define the functions for Brodeur 2020 plot 

# Create likelihood for non central t distribution
log_likelihood_nct <- function(df, ncp, observed_tvalues) {
  -sum(dt(observed_tvalues, df = df, ncp = ncp, log = TRUE))
}

# Create function to optimize parameters
optimize_parameters <- function(observed_tvalues, initial_df = 2, initial_ncp = 1.65) {
  # Define the log-likelihood function for optimization
  log_likelihood <- function(df, ncp) {
    log_likelihood_nct(df, ncp, observed_tvalues)
  }
  
  # Use optimization to estimate the parameters
  fit <- mle(log_likelihood, start = list(df = initial_df, ncp = initial_ncp))
  
  # Extract the estimated parameters
  df_est <- coef(fit)["df"]
  ncp_est <- coef(fit)["ncp"]
  
  return(list(df = df_est, ncp = ncp_est))
}

# Estimate parameters of counterfactual non-central t-distribution using all estimates with a z-Value larger than 5 (as in Brodeur 2020).
fit_all_periods <- function(data, threshold = 5) {
  results <- data %>%
    filter(z_stat > threshold) %>%
    group_by(period.month) %>%
    summarise(
      params = list(optimize_parameters(z_stat - threshold)),
      .groups = 'drop'
    ) %>%
    mutate(
      df = map_dbl(params, "df"),
      ncp = map_dbl(params, "ncp")
    )
  results$df_fit <- data.frame(
  period.month = sort(unique(data$period.month)),
  df = results$df
  )
  results$ncp_fit <- data.frame(
  period.month = sort(unique(data$period.month)),
  ncp = results$ncp
  )
  
  return(results)
}

# Create Brodeur data preparation function
brodeur_data_prep <- function (
    data = data,
    outvar = out_var,
    periods = 1:60,
    se_option = "avg",
    wins = wins_para,
    only_negative = TRUE,
    only_positive = FALSE
    ) {
  # Prepare data
  d_brodeur <- data %>% 
  filter(outcome == outvar, 
         period.month %in% periods) %>% 
  mutate(
    # Winsorization and SE option
    mean.effect = JWileymisc::winsorizor(mean.effect, percentile = wins),
    SE = case_when(
      se_option == "avg" ~ JWileymisc::winsorizor(SE.avg, percentile = wins),
      se_option == "upper" ~ JWileymisc::winsorizor(SE.upper, percentile = wins),
      se_option == "lower" ~ JWileymisc::winsorizor(SE.lower, percentile = wins)
    ),
    # Calculate z_stat
    z_stat = abs(mean.effect / SE)
    )
  
  # Extract only negative effects
  if (only_negative == TRUE & only_positive == FALSE) {
    d_brodeur <- d_brodeur %>% 
    filter(
      mean.effect <= 0
    )
  }
  # Extract only positive effects
  if (only_positive == TRUE & only_negative == FALSE) {
    d_brodeur <- d_brodeur %>% 
    filter(
      mean.effect >= 0
    )
  }
  return(d_brodeur)
}

# Define the plotting function
create_z_stat_plot <- function(data,
                               brodeur_results = results,
                               title = "Density of z-statistic",
                               counterfact_by_period = TRUE, 
                               facet_var = NULL,
                               yupper = 0.6,
                               nrow = NULL, 
                               ncol = NULL) {
  
  # Define significance levels and their z-values
  sig_levels <- c(1, 1.645, 1.960, 2.575)  # z-values for different significance levels
  
  p <- ggplot(data, aes(x = z_stat)) +
    geom_density(fill = "blue", alpha = 0.1, adjust = 0.7) +
    geom_histogram(aes(y = ..density..), 
                   breaks = c(seq(0,0.99,length.out = 10),
                              seq(0.99, 1.635, length.out = 6)[-1],
                              seq(1.635, 1.95, length.out = 3)[-1], 
                              seq(1.95, 2.565, length.out = 3)[-1],
                              seq(2.565, 15, 0.1)[-1]), 
                   alpha = 0.35) +
    geom_vline(xintercept = sig_levels, linetype = "dotted") +
    annotate("text", x = sig_levels[1] + (sig_levels[2] - sig_levels[1]) / 2, y = yupper - 0.01, 
             label = "*", size = 2.5) +
    annotate("text", x = sig_levels[2] + (sig_levels[3] - sig_levels[2]) / 2, y = yupper - 0.01, 
             label = "**", size = 2.5) +
    annotate("text", x = sig_levels[3] + (sig_levels[4] - sig_levels[3]) / 2, y = yupper - 0.01, 
             label = "***", size = 2.5) +
    annotate("text", x = sig_levels[4] + 0.5, y = yupper - 0.01, 
             label = "****", size = 2.5) +
    labs(title = title, x = "z-statistic (for negative effect sizes)", y = "") +
    xlim(-0.1, 10) +
    ylim(0, yupper) +
    theme_classic()
  
  if (counterfact_by_period == TRUE) {
    # Add t-distribution curves with df & ncp for each period
    for (period in sort(unique(data$period.month))) {
      curr_df <- brodeur_results$df_fit$df[brodeur_results$df_fit$period.month == period]
      curr_ncp <- brodeur_results$ncp_fit$ncp[brodeur_results$ncp_fit$period.month == period]

      p <- p + stat_function(
        fun = function(x) dt(x, df = curr_df, ncp = curr_ncp),
        data = data[data$period.month == period, ],
        color = "red", linetype = "solid", size = 0.5
      )
    }
  } else {
    # Add counterfactual with mean df & ncp
    p <- p + stat_function(
        fun = function(x) dt(x, df = mean(brodeur_results$df_fit$df), ncp = mean(brodeur_results$ncp_fit$ncp)),
        color = "red", linetype = "solid", size = 0.5
    )
  }
  
  # Add additional faceting if specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(as.formula(paste("~", facet_var)), scales = "free", nrow = nrow, ncol = ncol)
  } else {
    p <- p + facet_wrap(~ period.month, scales = "free")
  }
  
  return(p)
}

```

#### Output 

::: {.callout-important collapse="true"}
##### Output with SE.avg

```{r brodeur_density_plot_output_SEavg}
library(fitdistrplus)
library(stats4) 

out_var <- "output"

chosen_periods_brodeur <- c(0:60)

# Data prep
d_brodeur_neg <- brodeur_data_prep(data,
                                   outvar = out_var,
                                   se_option = "avg",
                                   periods = chosen_periods_brodeur,
                                   wins = wins_para,
                                   only_negative = TRUE,
                                   only_positive = FALSE)

# Fit distribution parameters and extract df & ncp
results <- fit_all_periods(d_brodeur_neg)

# Define stylized horizons 
vsr <- 6
smr <- 18
mlr <- 36
horizons <- c(
  paste0("impact to short run (0m - ", vsr - 1, "m)"),
  paste0("short run to medium run (", vsr, "m - ", smr, "m)"),
  paste0("medium run to long run (", smr + 1, "m - ", mlr, "m)"),
  paste0("long run (", mlr + 1, "m - ", chosen_periods_brodeur[length(chosen_periods_brodeur)], "m)")
)
d_brodeur_neg <- d_brodeur_neg %>% 
  mutate(horizon = case_when(
    period.month < vsr ~ horizons[1],
    (period.month >= vsr & period.month <= smr) ~ horizons[2],
    (period.month > smr & period.month <= mlr) ~ horizons[3],
    period.month > mlr ~ horizons[4]
    ),
    horizon = factor(horizon, levels = horizons)
  )

# Create density plots
# At period 3, 12, 24, 26
(brodeur_dens_3_12_24_36_output_avg <- create_z_stat_plot(d_brodeur_neg %>% filter(period.month %in% c(3, 12, 24, 36)),
                   brodeur_results = results,
                   counterfact_by_period = TRUE, 
                   yupper = 0.8, 
                   facet_var = "period.month",
                   title = NULL))
# At all periods
(brodeur_dens_all_periods_output_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.8, 
                   facet_var = "period.month",
                   title = NULL))
# At horizons
(brodeur_dens_horizons_output_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.8, 
                   facet_var = "horizon", ncol = 2,
                   title = NULL))
# For top tier journals
d_brodeur_neg$top_5_or_tier <- factor(d_brodeur_neg$top_5_or_tier, levels = c(0, 1), labels = c("other publication", "top journal"))
d_brodeur_neg %>% # For proportions by period
  count(period.month, top_5_or_tier) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n))
top_tier_journal_share_plot <- d_brodeur_neg %>% # Visualization with ggplot2
  ggplot(aes(x = period.month, fill = top_5_or_tier)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Publication Type") +
  theme_minimal()
(brodeur_dens_horizons_top_tier_output_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 0.8, 
                   facet_var = "horizon + top_5_or_tier", ncol = 2,
                   title = NULL))
d_brodeur_neg$is_top_5 <- factor(d_brodeur_neg$is_top_5, levels = c(0, 1), labels = c("other journals", "top 5"))
# For proportions by period
d_brodeur_neg %>%
  count(period.month, is_top_5) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n))
# Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = is_top_5)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_5_output_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 2.5, 
                   facet_var = "horizon + is_top_5", ncol = 2,
                   title = NULL))

```

:::

```{r brodeur_density_plot_output}
library(fitdistrplus)
library(stats4) 

out_var <- "output"

chosen_periods_brodeur <- c(0:60)

# Data prep
d_brodeur_neg <- brodeur_data_prep(data,
                                   outvar = out_var,
                                   se_option = "upper",
                                   periods = chosen_periods_brodeur,
                                   wins = wins_para,
                                   only_negative = TRUE,
                                   only_positive = FALSE)

# Fit distribution parameters and extract df & ncp
results <- fit_all_periods(d_brodeur_neg)

# Define stylized horizons 
vsr <- 6
smr <- 18
mlr <- 36
horizons <- c(
  paste0("impact to short run (0m - ", vsr - 1, "m)"),
  paste0("short run to medium run (", vsr, "m - ", smr, "m)"),
  paste0("medium run to long run (", smr + 1, "m - ", mlr, "m)"),
  paste0("long run (", mlr + 1, "m - ", chosen_periods_brodeur[length(chosen_periods_brodeur)], "m)")
)
d_brodeur_neg <- d_brodeur_neg %>% 
  mutate(horizon = case_when(
    period.month < vsr ~ horizons[1],
    (period.month >= vsr & period.month <= smr) ~ horizons[2],
    (period.month > smr & period.month <= mlr) ~ horizons[3],
    period.month > mlr ~ horizons[4]
    ),
    horizon = factor(horizon, levels = horizons)
  )

# Create density plots
# At period 3, 12, 24, 36
(brodeur_dens_3_12_24_36_output <- create_z_stat_plot(d_brodeur_neg %>% filter(period.month %in% c(3, 12, 24, 36)),
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.8, 
                   facet_var = "period.month",
                   title = NULL))
# At all periods
(brodeur_dens_all_periods_output <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.8, 
                   facet_var = "period.month",
                   title = NULL))
# At horizons 
(brodeur_dens_horizons_output <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.8, 
                   facet_var = "horizon", ncol = 2,
                   title = NULL))
# For top tier journals
d_brodeur_neg$top_5_or_tier <- factor(d_brodeur_neg$top_5_or_tier, levels = c(0, 1), labels = c("other publication", "top journal"))
d_brodeur_neg %>% # Proportions by period
  count(period.month, top_5_or_tier) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n))
top_tier_journal_share_plot <- d_brodeur_neg %>% # Visualization with ggplot2
  ggplot(aes(x = period.month, fill = top_5_or_tier)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Publication Type") +
  theme_minimal()
(brodeur_dens_horizons_top_tier_output <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 0.8, 
                   facet_var = "horizon + top_5_or_tier", ncol = 2,
                   title = NULL))
d_brodeur_neg$is_top_5 <- factor(d_brodeur_neg$is_top_5, levels = c(0, 1), labels = c("other journals", "top 5"))
d_brodeur_neg %>%# For proportions by period
  count(period.month, is_top_5) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n)) # Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = is_top_5)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_5_output <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 2.5, 
                   facet_var = "horizon + is_top_5", ncol = 2,
                   title = NULL))


# Other facets
# CB
d_brodeur_neg$cbanker <- factor(d_brodeur_neg$cbanker, levels = c(0, 1), labels = c("non-CB", "CB"))
(brodeur_dens_cbanker_output <- create_z_stat_plot(d_brodeur_neg,
                                               brodeur_results = results,
                                               counterfact_by_period = F, 
                                               yupper = 0.75,
                                               ncol = 2,
                                               facet_var = "horizon + cbanker",
                                               title = NULL))

# By identification method
(brodeur_dens_ident_output <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75, 
                                                       facet_var = "horizon + group_ident_broad",
                                                       title = NULL))
# By estimation method
(brodeur_dens_est_output <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75, 
                                                       facet_var = "horizon + group_est_broad",
                                                       title = NULL))
# Frequentist vs Bayesian
d_brodeur_neg$bayes <- factor(d_brodeur_neg$bayes, levels = c(0, 1), labels = c("Frequentist", "Bayesian"))
(brodeur_dens_bayes_output <- create_z_stat_plot(d_brodeur_neg,
                                                        brodeur_results = results,
                                                        counterfact_by_period = F, 
                                                        yupper = 0.75,
                                                        ncol = 2,
                                                        facet_var = "horizon + bayes",
                                                        title = NULL))

# Main research question
d_brodeur_neg$main_research_q <- factor(d_brodeur_neg$main_research_q, levels = c(0, 1), labels = c("Side result", "Main result"))
(brodeur_dens_main_research_q_output <- create_z_stat_plot(d_brodeur_neg,
                                                        brodeur_results = results,
                                                        counterfact_by_period = F, 
                                                        yupper = 0.75,
                                                        ncol = 2,
                                                        facet_var = "horizon + main_research_q",
                                                        title = NULL))
# By publication type 
(brodeur_dens_type_output <- create_z_stat_plot(d_brodeur_neg,
                                                   brodeur_results = results,
                                                   counterfact_by_period = F, 
                                                   yupper = 0.75,
                                                   ncol = 8,
                                                   facet_var = "horizon + type",
                                                   title = NULL))

# Panel vs non-panel
d_brodeur_neg$panel <- factor(d_brodeur_neg$panel, levels = c(0, 1), labels = c("non-panel", "panel"))
(brodeur_dens_panel_output <- create_z_stat_plot(d_brodeur_neg,
                                                brodeur_results = results,
                                                counterfact_by_period = F, 
                                                yupper = 0.75,
                                                ncol = 2,
                                                facet_var = "horizon + panel",
                                                title = NULL))

# By country dev
(brodeur_dens_country_dev_output <- create_z_stat_plot(d_brodeur_neg,
                                                brodeur_results = results,
                                                counterfact_by_period = F, 
                                                yupper = 0.75,
                                                ncol = 3,
                                                facet_var = "horizon + country_dev",
                                                title = NULL))

# By publication year
(brodeur_dens_pub_year_output <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75,
                                                       facet_var = "horizon + pub_year",
                                                       title = NULL))

# By frequency
d_brodeur_neg <- d_brodeur_neg %>%
  mutate(freq = case_when(
    month == 1 ~ "monthly",
    quarter == 1 ~ "quarterly",
    annual == 1 ~ "annual"
  )) 
(brodeur_dens_freq_output <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75,
                                                       ncol = 3,
                                                       facet_var = "horizon + freq",
                                                       title = NULL))
# Which is hacked: effect or SE? 
# Define the plotting function
# density_plot_effect <- function(data,
#                                title = "Density of effect or SE",
#                                facet_var = NULL,
#                                yupper = 1,
#                                nrow = NULL, 
#                                ncol = NULL) {
  
  p <- ggplot(d_brodeur_neg, aes(x = mean.effect)) + # ggplot(data, aes(x = mean.effect)) +
    geom_density(fill = "blue", alpha = 0.1, adjust = 0.7) +
    geom_histogram(aes(y = ..density..),
                   binwidth = 0.1, 
                   alpha = 0.35) +
    labs(title = title, x = "Density of negative effect sizes", y = "") +
    xlim(-2,0) +
    ylim(0, yupper) +
    theme_classic()
  
  # Add additional faceting if specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(as.formula(paste("~", facet_var)), scales = "free", nrow = nrow, ncol = ncol)
  } else {
    p <- p + facet_wrap(~ period.month, scales = "free")
  }
  
  # return(p)
# }

p
# Define the plotting function
# density_plot_se <- function(data,
#                                title = "Density of effect or SE",
#                                facet_var = NULL,
#                                yupper = 2.5,
#                                nrow = NULL, 
#                                ncol = NULL) {
  
  p <- ggplot(d_brodeur_neg, aes(x = SE)) + #ggplot(data, aes(x = SE)) +
    geom_density(fill = "blue", alpha = 0.1, adjust = 0.7) +
    geom_histogram(aes(y = ..density..),
                   binwidth = 0.1, 
                   alpha = 0.35) +
    labs(title = title, x = "Density of negative effect sizes", y = "") +
    ylim(0, yupper) +
    theme_classic()
  
  # Add additional faceting if specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(as.formula(paste("~", facet_var)), scales = "free", nrow = nrow, ncol = ncol)
  } else {
    p <- p + facet_wrap(~ period.month, scales = "free")
  }
  
  # return(p)
# }

p
```

#### Price level 


::: {.callout-important collapse="true"}
##### Price level with SE.avg

```{r brodeur_density_plot_pricelevel_avg}
library(fitdistrplus)
library(stats4) 

out_var <- "inflation"

chosen_periods_brodeur <- c(0:60)

# Data prep
d_brodeur_neg <- brodeur_data_prep(data,
                                   outvar = out_var,
                                   se_option = "avg",
                                   periods = chosen_periods_brodeur,
                                   wins = wins_para,
                                   only_negative = TRUE,
                                   only_positive = FALSE)

# Fit distribution parameters and extract df & ncp
results <- fit_all_periods(d_brodeur_neg)

# Define stylized horizons 
vsr <- 6
smr <- 18
mlr <- 36
horizons <- c(
  paste0("impact to short run (0m - ", vsr - 1, "m)"),
  paste0("short run to medium run (", vsr, "m - ", smr, "m)"),
  paste0("medium run to long run (", smr + 1, "m - ", mlr, "m)"),
  paste0("long run (", mlr + 1, "m - ", chosen_periods_brodeur[length(chosen_periods_brodeur)], "m)")
)
d_brodeur_neg <- d_brodeur_neg %>% 
  mutate(horizon = case_when(
    period.month < vsr ~ horizons[1],
    (period.month >= vsr & period.month <= smr) ~ horizons[2],
    (period.month > smr & period.month <= mlr) ~ horizons[3],
    period.month > mlr ~ horizons[4]
    ),
    horizon = factor(horizon, levels = horizons)
  )

# Create density plots
# At period 3, 12, 24, 26
(brodeur_dens_3_12_24_36_pricelevel_avg <- create_z_stat_plot(d_brodeur_neg %>% filter(period.month %in% c(3, 12, 24, 36)),
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.7, 
                   facet_var = "period.month",
                   title = NULL))
# At all periods
(brodeur_dens_all_periods_pricelevel_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1, 
                   facet_var = "period.month",
                   title = NULL))
# At horizons
(brodeur_dens_horizons_pricelevel_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.7, 
                   facet_var = "horizon", ncol = 2,
                   title = NULL))
# For top tier journals
d_brodeur_neg$top_5_or_tier <- factor(d_brodeur_neg$top_5_or_tier, levels = c(0, 1), labels = c("other journals", "top journals"))
d_brodeur_neg %>% # For proportions by period
  count(period.month, top_5_or_tier) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n)) # Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = top_5_or_tier)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_tier_pricelevel_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 0.7, 
                   facet_var = "horizon + top_5_or_tier", ncol = 2,
                   title = NULL))
d_brodeur_neg$is_top_5 <- factor(d_brodeur_neg$is_top_5, levels = c(0, 1), labels = c("other journals", "top 5"))
d_brodeur_neg %>% # For proportions by period
  count(period.month, is_top_5) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n)) # Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = is_top_5)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_5_pricelevel_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 2.5, 
                   facet_var = "horizon + is_top_5", ncol = 2,
                   title = NULL))
```

:::

```{r brodeur_density_plot_pricelevel}
library(fitdistrplus)
library(stats4) 

out_var <- "inflation"

chosen_periods_brodeur <- c(0:60)

# Data prep
d_brodeur_neg <- brodeur_data_prep(data,
                                   outvar = out_var,
                                   se_option = "upper",
                                   periods = chosen_periods_brodeur,
                                   wins = wins_para,
                                   only_negative = TRUE,
                                   only_positive = FALSE)

# Fit distribution parameters and extract df & ncp
results <- fit_all_periods(d_brodeur_neg)

# Define stylized horizons 
vsr <- 6
smr <- 18
mlr <- 36
horizons <- c(
  paste0("impact to short run (0m - ", vsr - 1, "m)"),
  paste0("short run to medium run (", vsr, "m - ", smr, "m)"),
  paste0("medium run to long run (", smr + 1, "m - ", mlr, "m)"),
  paste0("long run (", mlr + 1, "m - ", chosen_periods_brodeur[length(chosen_periods_brodeur)], "m)")
)
d_brodeur_neg <- d_brodeur_neg %>% 
  mutate(horizon = case_when(
    period.month < vsr ~ horizons[1],
    (period.month >= vsr & period.month <= smr) ~ horizons[2],
    (period.month > smr & period.month <= mlr) ~ horizons[3],
    period.month > mlr ~ horizons[4]
    ),
    horizon = factor(horizon, levels = horizons)
  )

# Create density plots
# At period 3, 12, 24, 26
(brodeur_dens_3_12_24_36_pricelevel <- create_z_stat_plot(d_brodeur_neg %>% filter(period.month %in% c(3, 12, 24, 36)),
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.7, 
                   facet_var = "period.month",
                   title = NULL))
# At all periods
(brodeur_dens_all_periods_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1, 
                   facet_var = "period.month",
                   title = NULL))
# At horizons
(brodeur_dens_horizons_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 0.7, 
                   facet_var = "horizon", ncol = 2,
                   title = NULL))
# For top tier journals
d_brodeur_neg$top_5_or_tier <- factor(d_brodeur_neg$top_5_or_tier, levels = c(0, 1), labels = c("other journals", "top journals"))
d_brodeur_neg %>% # For proportions by period
  count(period.month, top_5_or_tier) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n)) # Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = top_5_or_tier)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_tier_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 0.7, 
                   facet_var = "horizon + top_5_or_tier", ncol = 2,
                   title = NULL))
d_brodeur_neg$is_top_5 <- factor(d_brodeur_neg$is_top_5, levels = c(0, 1), labels = c("other journals", "top 5"))
d_brodeur_neg %>% # For proportions by period
  count(period.month, is_top_5) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n)) # Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = is_top_5)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_5_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 2.5, 
                   facet_var = "horizon + is_top_5", ncol = 2,
                   title = NULL))

# Other facets
d_brodeur_neg$cbanker <- factor(d_brodeur_neg$cbanker, levels = c(0, 1), labels = c("non-CB", "CB"))
(brodeur_dens_cbanker_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                               brodeur_results = results,
                                               counterfact_by_period = F, 
                                               yupper = 0.75,
                                               ncol = 2,
                                               facet_var = "horizon + cbanker",
                                               title = NULL))

# By identification method
(brodeur_dens_ident_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75, 
                                                       facet_var = "horizon + group_ident_broad",
                                                       title = NULL))
# By estimation method
(brodeur_dens_est_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75, 
                                                       facet_var = "horizon + group_est_broad",
                                                       title = NULL))
# Frequentist vs Bayesian
d_brodeur_neg$bayes <- factor(d_brodeur_neg$bayes, levels = c(0, 1), labels = c("Frequentist", "Bayesian"))
(brodeur_dens_bayes_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                        brodeur_results = results,
                                                        counterfact_by_period = F, 
                                                        yupper = 0.75,
                                                        ncol = 2,
                                                        facet_var = "horizon + bayes",
                                                        title = NULL))

# Main research question
d_brodeur_neg$main_research_q <- factor(d_brodeur_neg$main_research_q, levels = c(0, 1), labels = c("Side result", "Main result"))
(brodeur_dens_main_research_q_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                        brodeur_results = results,
                                                        counterfact_by_period = F, 
                                                        yupper = 0.75,
                                                        ncol = 2,
                                                        facet_var = "horizon + main_research_q",
                                                        title = NULL))
# By publication type 
(brodeur_dens_type_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                   brodeur_results = results,
                                                   counterfact_by_period = F, 
                                                   yupper = 0.75,
                                                   ncol = 8,
                                                   facet_var = "horizon + type",
                                                   title = NULL))

# Panel vs non-panel
d_brodeur_neg$panel <- factor(d_brodeur_neg$panel, levels = c(0, 1), labels = c("non-panel", "panel"))
(brodeur_dens_panel_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                brodeur_results = results,
                                                counterfact_by_period = F, 
                                                yupper = 0.75,
                                                ncol = 2,
                                                facet_var = "horizon + panel",
                                                title = NULL))

# By country dev
(brodeur_dens_country_dev_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                brodeur_results = results,
                                                counterfact_by_period = F, 
                                                yupper = 0.75,
                                                ncol = 3,
                                                facet_var = "horizon + country_dev",
                                                title = NULL))

# By publication year
(brodeur_dens_pub_year_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75,
                                                       facet_var = "horizon + pub_year",
                                                       title = NULL))

# By frequency
d_brodeur_neg <- d_brodeur_neg %>%
  mutate(freq = case_when(
    month == 1 ~ "monthly",
    quarter == 1 ~ "quarterly",
    annual == 1 ~ "annual"
  )) 
(brodeur_dens_freq_pricelevel <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75,
                                                       ncol = 3,
                                                       facet_var = "horizon + freq",
                                                       title = NULL))
# Which is hacked: effect or SE? 
# Define the plotting function
# density_plot_effect <- function(data,
#                                title = "Density of effect or SE",
#                                facet_var = NULL,
#                                yupper = 1,
#                                nrow = NULL, 
#                                ncol = NULL) {
  
  p <- ggplot(d_brodeur_neg, aes(x = mean.effect)) + # ggplot(data, aes(x = mean.effect)) +
    geom_density(fill = "blue", alpha = 0.1, adjust = 0.7) +
    geom_histogram(aes(y = ..density..),
                   binwidth = 0.1, 
                   alpha = 0.35) +
    labs(title = title, x = "Density of negative effect sizes", y = "") +
    ylim(0, yupper) +
    theme_classic()
  
  # Add additional faceting if specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(as.formula(paste("~", facet_var)), scales = "free", nrow = nrow, ncol = ncol)
  } else {
    p <- p + facet_wrap(~ period.month, scales = "free")
  }
  
  # return(p)
# }

p
# Define the plotting function
# density_plot_se <- function(data,
#                                title = "Density of effect or SE",
#                                facet_var = NULL,
#                                yupper = 2.5,
#                                nrow = NULL, 
#                                ncol = NULL) {
  
  p <- ggplot(d_brodeur_neg, aes(x = SE)) + # ggplot(data, aes(x = SE)) +
    geom_density(fill = "blue", alpha = 0.1, adjust = 0.7) +
    geom_histogram(aes(y = ..density..),
                   binwidth = 0.1, 
                   alpha = 0.35) +
    labs(title = title, x = "Density of negative effect sizes", y = "") +
    ylim(0, yupper) +
    theme_classic()
  
  # Add additional faceting if specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(as.formula(paste("~", facet_var)), scales = "free", nrow = nrow, ncol = ncol)
  } else {
    p <- p + facet_wrap(~ period.month, scales = "free")
  }
  
  # return(p)
# }

p

```


#### Interest rate

::: {.callout-warning}
##### TO DO:

- `chosen_periods_brodeur <- c(0:48)` # > 48 fails for some periods. Unclear why.

:::

::: {.callout-important collapse="true"}
##### Interest rate with SE.avg

```{r brodeur_density_plot_rate}
library(fitdistrplus)
library(stats4) 

out_var <- "rate"

chosen_periods_brodeur <- c(0:48) # > 48 fails for some periods. Unclear why.

# Data prep
d_brodeur_neg <- brodeur_data_prep(data,
                                   outvar = out_var,
                                   se_option = "avg",
                                   periods = chosen_periods_brodeur,
                                   wins = wins_para,
                                   only_negative = FALSE,
                                   only_positive = FALSE)

# Fit distribution parameters and extract df & ncp
results <- fit_all_periods(d_brodeur_neg)

# Define stylized horizons 
vsr <- 6
smr <- 18
mlr <- 36
horizons <- c(
  paste0("impact to short run (0m - ", vsr - 1, "m)"),
  paste0("short run to medium run (", vsr, "m - ", smr, "m)"),
  paste0("medium run to long run (", smr + 1, "m - ", mlr, "m)"),
  paste0("long run (", mlr + 1, "m - ", chosen_periods_brodeur[length(chosen_periods_brodeur)], "m)")
)
d_brodeur_neg <- d_brodeur_neg %>% 
  mutate(horizon = case_when(
    period.month < vsr ~ horizons[1],
    (period.month >= vsr & period.month <= smr) ~ horizons[2],
    (period.month > smr & period.month <= mlr) ~ horizons[3],
    period.month > mlr ~ horizons[4]
    ),
    horizon = factor(horizon, levels = horizons)
  )

# Create density plots
# At period 3, 12, 24, 26
(brodeur_dens_3_12_24_36_rate_avg <- create_z_stat_plot(d_brodeur_neg %>% filter(period.month %in% c(3, 12, 24, 36)),
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "period.month",
                   title = NULL)) + 
  labs(x = "z-statistic")
# At all periods
(brodeur_dens_all_periods_rate_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "period.month",
                   title = NULL)) + 
  labs(x = "z-statistic")
# At horizons
(brodeur_dens_horizons_rate_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "horizon", ncol = 2,
                   title = NULL)) + 
  labs(x = "z-statistic")
# For top tier journals
d_brodeur_neg$top_5_or_tier <- factor(d_brodeur_neg$top_5_or_tier, levels = c(0, 1), labels = c("other journals", "top journals"))
# For proportions by period
d_brodeur_neg %>%
  count(period.month, top_5_or_tier) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n))
# Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = top_5_or_tier)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_tier_rate_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "horizon + top_5_or_tier", ncol = 2,
                   title = NULL)) + 
  labs(x = "z-statistic")
d_brodeur_neg$is_top_5 <- factor(d_brodeur_neg$is_top_5, levels = c(0, 1), labels = c("other journals", "top 5"))
# For proportions by period
d_brodeur_neg %>%
  count(period.month, is_top_5) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n))
# Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = is_top_5)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_5_rate_avg <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 2.5, 
                   facet_var = "horizon + is_top_5", ncol = 2,
                   title = NULL)) + 
  labs(x = "z-statistic")
```

:::

```{r brodeur_density_plot_rate}
library(fitdistrplus)
library(stats4) 

out_var <- "rate"

chosen_periods_brodeur <- c(0:48) # > 48 fails, unclear why

# Data prep
d_brodeur_neg <- brodeur_data_prep(data,
                                   outvar = out_var,
                                   se_option = "lower",
                                   periods = chosen_periods_brodeur,
                                   wins = wins_para,
                                   only_negative = FALSE,
                                   only_positive = FALSE)

# Fit distribution parameters and extract df & ncp
results <- fit_all_periods(d_brodeur_neg)

# Define stylized horizons 
vsr <- 6
smr <- 18
mlr <- 36
horizons <- c(
  paste0("impact to short run (0m - ", vsr - 1, "m)"),
  paste0("short run to medium run (", vsr, "m - ", smr, "m)"),
  paste0("medium run to long run (", smr + 1, "m - ", mlr, "m)"),
  paste0("long run (", mlr + 1, "m - ", chosen_periods_brodeur[length(chosen_periods_brodeur)], "m)")
)
d_brodeur_neg <- d_brodeur_neg %>% 
  mutate(horizon = case_when(
    period.month < vsr ~ horizons[1],
    (period.month >= vsr & period.month <= smr) ~ horizons[2],
    (period.month > smr & period.month <= mlr) ~ horizons[3],
    period.month > mlr ~ horizons[4]
    ),
    horizon = factor(horizon, levels = horizons)
  )

# Create density plots
# At period 3, 12, 24, 26
(brodeur_dens_3_12_24_36_rate <- create_z_stat_plot(d_brodeur_neg %>% filter(period.month %in% c(3, 12, 24, 36)),
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "period.month",
                   title = NULL)) + 
  labs(x = "z-statistic")
# At all periods
(brodeur_dens_all_periods_rate <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "period.month",
                   title = NULL)) + 
  labs(x = "z-statistic")
# At horizons
(brodeur_dens_horizons_rate <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results,
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "horizon", ncol = 2,
                   title = NULL)) + 
  labs(x = "z-statistic")
# For top tier journals
d_brodeur_neg$top_5_or_tier <- factor(d_brodeur_neg$top_5_or_tier, levels = c(0, 1), labels = c("other journals", "top journals"))
# For proportions by period
d_brodeur_neg %>%
  count(period.month, top_5_or_tier) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n))
# Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = top_5_or_tier)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_tier_rate <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 1.5, 
                   facet_var = "horizon + top_5_or_tier", ncol = 2,
                   title = NULL)) + 
  labs(x = "z-statistic")
d_brodeur_neg$is_top_5 <- factor(d_brodeur_neg$is_top_5, levels = c(0, 1), labels = c("other journals", "top 5"))
# For proportions by period
d_brodeur_neg %>%
  count(period.month, is_top_5) %>%
  group_by(period.month) %>%
  mutate(proportion = n / sum(n))
# Visualization with ggplot2
d_brodeur_neg %>%
  ggplot(aes(x = period.month, fill = is_top_5)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Journals by Period",
       x = "Period",
       y = "Count",
       fill = "Journal Type") +
  theme_minimal()
(brodeur_dens_horizons_top_5_rate <- create_z_stat_plot(d_brodeur_neg,
                   brodeur_results = results, 
                   counterfact_by_period = F, 
                   yupper = 2.5, 
                   facet_var = "horizon + is_top_5", ncol = 2,
                   title = NULL)) + 
  labs(x = "z-statistic")


# Other facets
d_brodeur_neg$cbanker <- factor(d_brodeur_neg$cbanker, levels = c(0, 1), labels = c("non-CB", "CB"))
(brodeur_dens_cbanker_rate <- create_z_stat_plot(d_brodeur_neg,
                                               brodeur_results = results,
                                               counterfact_by_period = F, 
                                               yupper = 0.75,
                                               ncol = 2,
                                               facet_var = "horizon + cbanker",
                                               title = NULL))

# By identification method
(brodeur_dens_ident_rate <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75, 
                                                       facet_var = "horizon + group_ident_broad",
                                                       title = NULL))
# By estimation method
(brodeur_dens_est_rate <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75, 
                                                       facet_var = "horizon + group_est_broad",
                                                       title = NULL))
# Frequentist vs Bayesian
d_brodeur_neg$bayes <- factor(d_brodeur_neg$bayes, levels = c(0, 1), labels = c("Frequentist", "Bayesian"))
(brodeur_dens_bayes_rate <- create_z_stat_plot(d_brodeur_neg,
                                                        brodeur_results = results,
                                                        counterfact_by_period = F, 
                                                        yupper = 0.75,
                                                        ncol = 2,
                                                        facet_var = "horizon + bayes",
                                                        title = NULL))

# Main research question
d_brodeur_neg$main_research_q <- factor(d_brodeur_neg$main_research_q, levels = c(0, 1), labels = c("Side result", "Main result"))
(brodeur_dens_main_research_q_rate <- create_z_stat_plot(d_brodeur_neg,
                                                        brodeur_results = results,
                                                        counterfact_by_period = F, 
                                                        yupper = 0.75,
                                                        ncol = 2,
                                                        facet_var = "horizon + main_research_q",
                                                        title = NULL))
# By publication type 
(brodeur_dens_type_rate <- create_z_stat_plot(d_brodeur_neg,
                                                   brodeur_results = results,
                                                   counterfact_by_period = F, 
                                                   yupper = 0.75,
                                                   ncol = 8,
                                                   facet_var = "horizon + type",
                                                   title = NULL))

# Panel vs non-panel
d_brodeur_neg$panel <- factor(d_brodeur_neg$panel, levels = c(0, 1), labels = c("non-panel", "panel"))
(brodeur_dens_panel_rate <- create_z_stat_plot(d_brodeur_neg,
                                                brodeur_results = results,
                                                counterfact_by_period = F, 
                                                yupper = 0.75,
                                                ncol = 2,
                                                facet_var = "horizon + panel",
                                                title = NULL))

# By country dev
(brodeur_dens_country_dev_rate <- create_z_stat_plot(d_brodeur_neg,
                                                brodeur_results = results,
                                                counterfact_by_period = F, 
                                                yupper = 0.75,
                                                ncol = 3,
                                                facet_var = "horizon + country_dev",
                                                title = NULL))

# By publication year
(brodeur_dens_pub_year_rate <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75,
                                                       facet_var = "horizon + pub_year",
                                                       title = NULL))

# By frequency
d_brodeur_neg <- d_brodeur_neg %>%
  mutate(freq = case_when(
    month == 1 ~ "monthly",
    quarter == 1 ~ "quarterly",
    annual == 1 ~ "annual"
  )) 
(brodeur_dens_freq_rate <- create_z_stat_plot(d_brodeur_neg,
                                                       brodeur_results = results,
                                                       counterfact_by_period = F, 
                                                       yupper = 0.75,
                                                       ncol = 3,
                                                       facet_var = "horizon + freq",
                                                       title = NULL))
# Which is hacked: effect or SE? 
# Define the plotting function
# density_plot_effect <- function(data,
#                                title = "Density of effect or SE",
#                                facet_var = NULL,
#                                yupper = 1,
#                                nrow = NULL, 
#                                ncol = NULL) {
  
  p <- ggplot(d_brodeur_neg, aes(x = mean.effect)) + # ggplot(data, aes(x = mean.effect)) +
    geom_density(fill = "blue", alpha = 0.1, adjust = 0.7) +
    geom_histogram(aes(y = ..density..),
                   binwidth = 0.1, 
                   alpha = 0.35) +
    labs(title = title, x = "Density of negative effect sizes", y = "") +
    ylim(0, yupper) +
    theme_classic()
  
  # Add additional faceting if specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(as.formula(paste("~", facet_var)), scales = "free", nrow = nrow, ncol = ncol)
  } else {
    p <- p + facet_wrap(~ period.month, scales = "free")
  }
  
  # return(p)
# }

p
# Define the plotting function
# density_plot_se <- function(data,
#                                title = "Density of effect or SE",
#                                facet_var = NULL,
#                                yupper = 2.5,
#                                nrow = NULL, 
#                                ncol = NULL) {
  
  p <- ggplot(d_brodeur_neg, aes(x = SE)) + # ggplot(data, aes(x = SE)) +
    geom_density(fill = "blue", alpha = 0.1, adjust = 0.7) +
    geom_histogram(aes(y = ..density..),
                   binwidth = 0.1, 
                   alpha = 0.35) +
    labs(title = title, x = "Density of negative effect sizes", y = "") +
    ylim(0, yupper) +
    theme_classic()
  
  # Add additional faceting if specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(as.formula(paste("~", facet_var)), scales = "free", nrow = nrow, ncol = ncol)
  } else {
    p <- p + facet_wrap(~ period.month, scales = "free")
  }
  
  # return(p)
# }

p
```


### AK density plots

## Simple p-bias estimations & IRF corrections

::: {.callout-tip}
### Suggestion for `se_option`

At the moment, we use `se_option = "avg"` in all estimations. 

I (Franz) would be in favor of setting the se_option specifically to the outcome variable. I think it makes more sense, even if it does not change results dramatically.

Suggestion: 

- Output: `se_option = "upper"`
- Price level: `se_option = "upper"`
- Unemployment rate: `se_option = "lower"`
- Employment: `se_option = "upper"`
- Rate: `se_option = "avg"`
:::

::: {.callout-important}
### TO DO: Other estimations

- UWLS
- FAT-PET
- EK
- AK estimation plots
- Stem
- MAIVE
:::


### Output 

#### Estimation

##### PEESE

```{r peese_pub_bias_output}

out_var <- "output"

# Equation
display_equation("PEESE", weighted = TRUE)

# Estimation
output_peese <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          prec_weighted = TRUE,
                          estimation = "PEESE",
                          cluster_se = TRUE)

# Cleaner names in table
coef_names_output_peese <- c(
  "(Intercept)" = "Intercept",
  "variance_winsor" = "Variance")

# Create html table
modelsummary::modelsummary(output_peese,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("PEESE", out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_output_peese)

# Model plot - intercept - corrected effect
omit <- "variance_winsor"
b <- list(geom_vline(xintercept = 0, color = 'orange'))
modelsummary::modelplot(output_peese,
              coef_omit = omit,
              conf_level = conflevel,
              title = "PEESE output - corrected effect", 
              background = b)

# Model plot - variance - publication bias
omit <- "Interc"
modelplot(output_peese,
          coef_omit = omit,
          conf_level = conflevel,
          title = "PEESE output - p-bias", 
          background = b)
  

```

##### WAAP 

::: {.callout-warning}
###### Correct WAAP implementation?

- Estimated equation correct?

$$t = y/SE = \beta (1/SE) + \epsilon$$
- Correct to not cluster SEs and no precision weighting for WAAP?
:::

```{r waap_pub_bias_output}

# Equation
display_equation("UWLS", weighted = FALSE)

# Estimation
output_waap <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          ap = TRUE,
                          prec_weighted = FALSE,
                          estimation = "UWLS",
                          cluster_se = FALSE)

# Cleaner names in table
coef_names_output_waap <- c(
  "precision_winsor" = "Precision")

# Create html table
modelsummary::modelsummary(output_waap,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("WAAP", out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_output_waap)

# Model plot - intercept - corrected effect
omit <- NULL
modelsummary::modelplot(output_waap,
              coef_omit = omit,
              conf_level = conflevel,
              title = "WAAP output - corrected effect", 
              background = b)

```

##### AK

::: {.callout-warning}
###### Correct interpretation of AK?

Check if our interpretation of $\mu$ as corrected effect and $\tau$ as publication bias is correct. 

:::

```{r ak_pub_bias_output}

# Estimation
output_ak <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          prec_weighted = FALSE,
                          estimation = "AK",
                          cluster_se = TRUE,
                          cutoff_val=1, # 68 % level as cutoff
                          AK_modelmu = "t",
                          AK_symmetric = FALSE,
                          AK_conf_level = conflevel,
                          ak_plot = "pub_prob_only"
                          )

# Create html table
modelsummary::modelsummary(output_ak,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("AK", out_var), 
                           gof_map = NULL)

# Model plot - intercept - corrected effect
omit <- 2:nrow(output_ak[[1]]$tidy[1])
modelsummary::modelplot(output_ak,
              coef_omit = omit,
              conf_level = conflevel,
              title = "AK output - corrected effect", 
              background = b)

# Model plot - publication bias
omit <- c(1,3:nrow(output_ak[[1]]$tidy[1]))
modelsummary::modelplot(output_ak,
              coef_omit = omit,
              conf_level = conflevel,
              title = "AK output - corrected effect", 
              background = b)

```


#### IRF correction

```{r corrected_irf_output}

# Extract PEESE correction
corrected_irf_output_peese <- as.data.frame(
  do.call(
    rbind,lapply(output_peese, extract_intercepts, method = "PESEE")
    )
  )
corrected_irf_output_peese$period<-as.numeric(rownames(corrected_irf_output_peese))

# Extract WAAP correction
corrected_irf_output_waap <- as.data.frame(
  do.call(
    rbind,lapply(output_waap, extract_intercepts, method = "UWLS")
    )
  )
corrected_irf_output_waap$period<-as.numeric(rownames(corrected_irf_output_waap))

# Extract AK correction
corrected_irf_output_ak <- as.data.frame(
  do.call(
    rbind,lapply(output_ak, extract_intercepts, method = "AK")
    )
  )
corrected_irf_output_ak$period<-as.numeric(rownames(corrected_irf_output_ak))

# Create corrected IRF plot
corrected_irf_output <- avg_irf_output %>%
  add_lines(
    data = corrected_irf_output_peese,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  ) %>% 
  add_ribbons(
    data = corrected_irf_output_peese,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
    ) %>%
  add_lines(
    data = corrected_irf_output_waap,
    x = ~period,
    y = ~estimate,
    name = "WAAP correction Mean",
    line = list(color = 'rgba(125, 103, 138, 0.89)')
  ) %>% 
  add_ribbons(
    data = corrected_irf_output_waap,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "WAAP correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(100,20,200,0.2)'
    ) %>%
  add_ribbons(
    data = corrected_irf_output_ak,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "AK correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(118, 37, 166, 0.8)'
  ) %>%
  add_lines(
    data = corrected_irf_output_ak,
    x = ~period,
    y = ~estimate,
    name = "AK correction Mean",
    line = list(color = 'rgba(55, 13, 79, 0.89)')
  )

corrected_irf_output
```

### Price level

#### Estimation

##### PEESE

```{r peese_pub_bias_pricelevel}

out_var <- "inflation"

# Equation
display_equation("PEESE", weighted = TRUE)

# Estimation
pricelevel_peese <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          prec_weighted = TRUE,
                          estimation = "PEESE",
                          cluster_se = TRUE)

# Cleaner names in table
coef_names_pricelevel_peese <- c(
  "(Intercept)" = "Intercept",
  "variance_winsor" = "Variance")

# Create html table
modelsummary::modelsummary(pricelevel_peese,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("PEESE", out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_pricelevel_peese)

# Model plot - intercept - corrected effect
omit <- "variance_winsor"
b <- list(geom_vline(xintercept = 0, color = 'orange'))
modelsummary::modelplot(pricelevel_peese,
              coef_omit = omit,
              conf_level = conflevel,
              title = "PEESE pricelevel - corrected effect", 
              background = b)

# Model plot - variance - publication bias
omit <- "Interc"
modelplot(pricelevel_peese,
          coef_omit = omit,
          conf_level = conflevel,
          title = "PEESE pricelevel - p-bias", 
          background = b)
  

```
##### WAAP 

::: {.callout-warning}
###### Correct WAAP implementation?

- Estimated equation correct?

$$t = y/SE = \beta (1/SE) + \epsilon$$
- Correct to not cluster SEs and no precision weighting for WAAP?
:::

```{r waap_pub_bias_pricelevel}

# Equation
display_equation("UWLS", weighted = FALSE)

# Estimation
pricelevel_waap <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          ap = TRUE,
                          prec_weighted = FALSE,
                          estimation = "UWLS",
                          cluster_se = FALSE)

# Cleaner names in table
coef_names_pricelevel_waap <- c(
  "precision_winsor" = "Precision")

# Create html table
modelsummary::modelsummary(pricelevel_waap,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("WAAP", out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_pricelevel_waap)

# Model plot - intercept - corrected effect
omit <- NULL
modelsummary::modelplot(pricelevel_waap,
              coef_omit = omit,
              conf_level = conflevel,
              title = "WAAP pricelevel - corrected effect", 
              background = b)

```

##### AK

::: {.callout-warning}
###### Correct interpretation of AK?

Check if our interpretation of $\mu$ as corrected effect and $\tau$ as publication bias is correct. 

:::

```{r ak_pub_bias_pricelevel}

# Estimation
pricelevel_ak <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          prec_weighted = FALSE,
                          estimation = "AK",
                          cluster_se = TRUE,
                          cutoff_val = 1, # 68 % level as cutoff
                          AK_modelmu = "t",
                          AK_symmetric = FALSE,
                          AK_conf_level = conflevel,
                          ak_plot = "pub_prob_only"
                          )

# Create html table
modelsummary::modelsummary(pricelevel_ak,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("AK", out_var), 
                           gof_map = NULL)

# Model plot - intercept - corrected effect
omit <- 2:nrow(pricelevel_ak[[1]]$tidy[1])
modelsummary::modelplot(pricelevel_ak,
              coef_omit = omit,
              conf_level = conflevel,
              title = "AK pricelevel - corrected effect", 
              background = b)

# Model plot - publication bias
omit <- c(1,3:nrow(pricelevel_ak[[1]]$tidy[1]))
modelsummary::modelplot(pricelevel_ak,
              coef_omit = omit,
              conf_level = conflevel,
              title = "AK pricelevel - corrected effect", 
              background = b)

```

#### IRF correction

```{r corrected_irf_pricelevel}

# Extract PEESE correction
corrected_irf_pricelevel_peese <- as.data.frame(
  do.call(
    rbind,lapply(pricelevel_peese, extract_intercepts, method = "PESEE")
    )
  )
corrected_irf_pricelevel_peese$period<-as.numeric(rownames(corrected_irf_pricelevel_peese))

# Extract WAAP correction
corrected_irf_pricelevel_waap <- as.data.frame(
  do.call(
    rbind,lapply(pricelevel_waap, extract_intercepts, method = "UWLS")
    )
  )
corrected_irf_pricelevel_waap$period<-as.numeric(rownames(corrected_irf_pricelevel_waap))

# Extract AK correction
corrected_irf_pricelevel_ak <- as.data.frame(
  do.call(
    rbind,lapply(pricelevel_ak, extract_intercepts, method = "AK")
    )
  )
corrected_irf_pricelevel_ak$period<-as.numeric(rownames(corrected_irf_pricelevel_ak))

# Create corrected IRF plot
corrected_irf_pricelevel <- avg_irf_pricelevel %>%
  add_lines(
    data = corrected_irf_pricelevel_peese,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  ) %>% 
  add_ribbons(
    data = corrected_irf_pricelevel_peese,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
    ) %>%
  add_lines(
    data = corrected_irf_pricelevel_waap,
    x = ~period,
    y = ~estimate,
    name = "WAAP correction Mean",
    line = list(color = 'rgba(125, 103, 138, 0.89)')
  ) %>% 
  add_ribbons(
    data = corrected_irf_pricelevel_waap,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "WAAP correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(100,20,200,0.2)'
    ) %>%
  add_ribbons(
    data = corrected_irf_pricelevel_ak,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "AK correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(118, 37, 166, 0.8)'
  ) %>%
  add_lines(
    data = corrected_irf_pricelevel_ak,
    x = ~period,
    y = ~estimate,
    name = "AK correction Mean",
    line = list(color = 'rgba(55, 13, 79, 0.89)')
  )

corrected_irf_pricelevel
```


### Unemploynment

#### Estimation

#### IRF correction

### Employment 

#### Estimation

#### IRF correction

### Interest rate

#### Estimation

##### PEESE

```{r peese_pub_bias_rate}

out_var <- "rate"

# Equation
display_equation("PEESE", weighted = TRUE)

# Estimation
rate_peese <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          prec_weighted = TRUE,
                          estimation = "PEESE",
                          cluster_se = TRUE)

# Cleaner names in table
coef_names_rate_peese <- c(
  "(Intercept)" = "Intercept",
  "variance_winsor" = "Variance")

# Create html table
modelsummary::modelsummary(rate_peese,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("PEESE", out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_rate_peese)

# Model plot - intercept - corrected effect
omit <- "variance_winsor"
b <- list(geom_vline(xintercept = 0, color = 'orange'))
modelsummary::modelplot(rate_peese,
              coef_omit = omit,
              conf_level = conflevel,
              title = "PEESE rate - corrected effect", 
              background = b)

# Model plot - variance - publication bias
omit <- "Interc"
modelplot(rate_peese,
          coef_omit = omit,
          conf_level = conflevel,
          title = "PEESE rate - p-bias", 
          background = b)
  

```
##### WAAP 

::: {.callout-warning}
###### Correct WAAP implementation?

- Estimated equation correct?

$$t = y/SE = \beta (1/SE) + \epsilon$$
- Correct to not cluster SEs and no precision weighting for WAAP?
:::

```{r waap_pub_bias_rate}

# Equation
display_equation("UWLS", weighted = FALSE)

# Estimation
rate_waap <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          ap = TRUE,
                          prec_weighted = FALSE,
                          estimation = "UWLS",
                          cluster_se = FALSE)

# Cleaner names in table
coef_names_rate_waap <- c(
  "precision_winsor" = "Precision")

# Create html table
modelsummary::modelsummary(rate_waap,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("WAAP", out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_rate_waap)

# Model plot - intercept - corrected effect
omit <- NULL
modelsummary::modelplot(rate_waap,
              coef_omit = omit,
              conf_level = conflevel,
              title = "WAAP rate - corrected effect", 
              background = b)

```

##### AK

::: {.callout-warning}
###### Correct interpretation of AK?

Check if our interpretation of $\mu$ as corrected effect and $\tau$ as publication bias is correct. 

:::

```{r ak_pub_bias_rate}

# Estimation
rate_ak <- meta_analysis(data,
                          outvar = out_var,
                          se_option = "avg",
                          periods = chosen_periods,
                          wins = wins_para,
                          prec_weighted = FALSE,
                          estimation = "AK",
                          cluster_se = TRUE,
                          cutoff_val = 1, # 68 % level as cutoff
                          AK_modelmu = "t",
                          AK_symmetric = FALSE,
                          AK_conf_level = conflevel
                          )

# Create html table
modelsummary::modelsummary(rate_ak,
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel,
                           statistic = c("se = {std.error}","conf.int"),
                           title = paste("AK", out_var), 
                           gof_map = NULL)

# Model plot - intercept - corrected effect
omit <- 2:nrow(rate_ak[[1]]$tidy[1])
modelsummary::modelplot(rate_ak,
              coef_omit = omit,
              conf_level = conflevel,
              title = "AK rate - corrected effect", 
              background = b)

# Model plot - publication bias
omit <- c(1,3:nrow(rate_ak[[1]]$tidy[1]))
modelsummary::modelplot(rate_ak,
              coef_omit = omit,
              conf_level = conflevel,
              title = "AK rate - corrected effect", 
              background = b)

```

#### IRF correction

```{r corrected_irf_rate}

# Extract PEESE correction
corrected_irf_rate_peese <- as.data.frame(
  do.call(
    rbind,lapply(rate_peese, extract_intercepts, method = "PESEE")
    )
  )
corrected_irf_rate_peese$period<-as.numeric(rownames(corrected_irf_rate_peese))

# Extract WAAP correction
corrected_irf_rate_waap <- as.data.frame(
  do.call(
    rbind,lapply(rate_waap, extract_intercepts, method = "UWLS")
    )
  )
corrected_irf_rate_waap$period<-as.numeric(rownames(corrected_irf_rate_waap))

# Extract AK correction
corrected_irf_rate_ak <- as.data.frame(
  do.call(
    rbind,lapply(rate_ak, extract_intercepts, method = "AK")
    )
  )
corrected_irf_rate_ak$period<-as.numeric(rownames(corrected_irf_rate_ak))

# Create corrected IRF plot
corrected_irf_rate <- avg_irf_rate %>%
  add_lines(
    data = corrected_irf_rate_peese,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  ) %>% 
  add_ribbons(
    data = corrected_irf_rate_peese,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
    ) %>%
  add_lines(
    data = corrected_irf_rate_waap,
    x = ~period,
    y = ~estimate,
    name = "WAAP correction Mean",
    line = list(color = 'rgba(125, 103, 138, 0.89)')
  ) %>% 
  add_ribbons(
    data = corrected_irf_rate_waap,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "WAAP correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(100,20,200,0.2)'
    ) %>%
  add_ribbons(
    data = corrected_irf_rate_ak,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "AK correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(118, 37, 166, 0.8)'
  ) %>%
  add_lines(
    data = corrected_irf_rate_ak,
    x = ~period,
    y = ~estimate,
    name = "AK correction Mean",
    line = list(color = 'rgba(55, 13, 79, 0.89)')
  )

corrected_irf_rate
```

### IRF correction all variables

::: {.callout-important}
### TO DO: Corrections for other estimations

- UWLS
- FAT-PET
- EK
- AK estimation plots
- Stem
- MAIVE
:::


```{r corrected_irf_all_4}

subplot(corrected_irf_output, corrected_irf_pricelevel, 
        # corrected_irf_unemp_emp, 
        corrected_irf_rate, nrows = 2, margin = 0.1) %>% layout(
          showlegend=FALSE,
          title = 'Corrected effects of conventional monetary policy',
          xaxis4 = list(title = "Month"), # x-axis for plot 3
          xaxis5 = list(title = "Months")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.2, y = 1, text = "Output", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.8, y = 1, text = "Price level", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  # list(x = 0.2, y = 0.45, text = "Unemployment rate", showarrow = FALSE, xref = "paper", yref = "paper",
  #      xanchor = "center", yanchor = "bottom"),
  list(x = 0.2, y = 0.45, text = "Interest rate", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom")
),
margin = list(t = 80))
```

# Moderator variables and study heterogeneity

::: {.callout-important}
## TO DO: This section needs clearer structure and connection to hypotheses

:::

## FLAGSHIP PAPER - Identification and estimation approaches

::: {.callout-note}

This specification is motivated by our hypotheses about identification and estimation procedures (H7/H8) and certain publication characteristics, like journal impact factors (H2) and central bank affiliation (H9).

We focus on the relevance of different identification and estimation approaches. In particular, we consolidate our models into more parsimonious identification and estimation categories based on our raw coding to enlarge the sample size for each identification or estimation category.

Furthermore, we also control for selected other influences, especially publication characteristics like `top_5_or_tier` and `cbanker` and the specific variable used to measure the outcome variable (`outcome_measure`) and also for Bayesian and frequentist estimation (`bayes`). 

The data used excludes studies with `quality_concern`s and is winsorized at the `{r} wins_para * 100` % level. We use a PEESE specification.

:::

::: {.callout-important}
#### TO DO: Creation of `group_est_broad` in `data_prep.R`

The creation of `group_est_broad` should be done in the `data_prep.R` file analogous to the identification categories.
```{r}
#| code-fold: true

# Consolidate estimation methods
data <- data %>%
  mutate(group_est_broad = case_when(
    # Group 1: var, standard VAR
    (var == 1 & lp == 0 & vecm == 0 & dyn_ols == 0 & fvar == 0 & tvar == 0 & gvar == 0 & dsge == 0 & varother == 0) ~ "standard_var",
    
    # Group 2: lp_ardl
    ((lp == 1 | dyn_ols == 1) & fvar == 0) ~ "lp_ardl",
    
    # Group 3: favar
    (fvar == 1) ~ "favar",
    
    # Group 4: other_var
    ((varother == 1 | tvar == 1 | gvar == 1 | vecm == 1) & lp == 0 & dyn_ols == 0 & fvar == 0 & dsge == 0) ~ "other_var",
    
    # Group 5: dsge
    (dsge == 1) ~ "dsge",
    
    # Default case
    TRUE ~ "Other"

))

# Transform into factor and make "standard_var" the reference 
data$group_est_broad <- factor(data$group_est_broad, 
                               levels = c("standard_var", 
                                          "lp_ardl", 
                                          "favar", 
                                          "other_var", 
                                          "dsge"))
levels(data$group_est_broad)

```
::: 

### Output

::: {.callout-note}
##### WP 1 Baseline: identification methods + top journals + CB related

```{r peese_output_ident_consolidated}

out_var <- "output"

# Periods for FMM conference
chosen_periods_fmm <- c(3, 
                        6, 
                        9,
                        12, 
                        15,
                        18, 
                        21,
                        24, 
                        30,
                        36, 
                        48,
                        60)

output_wp1_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          # periods = chosen_periods,
                          periods = chosen_periods_fmm,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier",
                                   "cbanker"))

coef_names_baseline <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'group_ident_broadhf' = 'High frequency', 
  'group_ident_broadnr' = 'Narrative',
  'group_ident_broadsignr' = 'Sign restrictions',
  'group_ident_broadidother' = 'Other identificiation ',
  'top_5_or_tier' = 'Top tier publication',
  'cbanker' = 'Central bank related')

# Create html output
modelsummary::modelsummary(output_wp1_baseline, 
                           output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

# For FMM presentation
modelsummary::modelsummary(output_wp1_baseline, 
                           output = "outputs_for_working_papers/wp1/discuss/baseline_meta_reg_output.png",
                           stars = TRUE, 
                           fmt = 2,
                           statistic = NULL,
                           conf_level = conflevel, 
                           gof_map = "nobs", 
                           coef_map = coef_names_baseline)

```
:::


::: {.callout-note}
##### WP 1 Robustness: + estimation methods & outcome_measure

```{r peese_output_ident_est_consolidated}

# Create consolidated `outcome_measure_output_cons` for output, transform into factor and make "gdp" (now including "gnp") the reference (only a very small number of observations uses "gnp")
data <- data %>%
  mutate(outcome_measure_output_cons = case_when(
    outcome == "output" & outcome_measure == "gnp" ~ "gdp",
    outcome == "output" ~ outcome_measure,
    TRUE ~ NA_character_  # For non-output rows
  )) %>%
  mutate(outcome_measure_output_cons = factor(outcome_measure_output_cons, 
                                       levels = c("gdp", "ip", "gap")))

output_wp1_baseline_robustness <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          # periods = chosen_periods,
                          periods = chosen_periods_fmm,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "group_est_broad",
                                   "outcome_measure_output_cons",
                                   "top_5_or_tier",
                                   "cbanker"))

coef_names_baseline <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'group_ident_broadhf' = 'High frequency', 
  'group_ident_broadnr' = 'Narrative',
  'group_ident_broadsignr' = 'Sign restrictions',
  'group_ident_broadidother' = 'Other identificiation ',
  'top_5_or_tier' = 'Top tier publication',
  'cbanker' = 'Central bank related',
  'group_est_broadlp_ardl' = 'LP and ARDL',
  'group_est_broadfavar' = 'FAVAR', 
  'group_est_broadother_var' = 'Other VAR',
  'group_est_broaddsge' = 'DSGE',
  'outcome_measure_output_consgap' = 'Output gap',
  'outcome_measure_output_consip' = 'IP')

# Create html output
modelsummary::modelsummary(output_wp1_baseline_robustness, 
                           output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

# For FMM presentation
modelsummary::modelsummary(output_wp1_baseline_robustness, 
                           output = "outputs_for_working_papers/wp1/discuss/robustness_meta_reg_output.png",
                           stars = TRUE, 
                           fmt = 2,
                           statistic = NULL,
                           conf_level = conflevel, 
                           gof_map = "nobs", 
                           coef_map = coef_names_baseline)

```
:::

### Price level

::: {.callout-note}
##### WP 1 Baseline: identification methods + top journals + CB related

```{r peese_pricelevel_ident_consolidated}

out_var <- "inflation"

# Periods for FMM conference
chosen_periods_fmm <- c(3, 
                        6, 
                        12, 
                        18, 
                        24, 
                        30,
                        36,
                        42,
                        48,
                        54,
                        60)

pricelevel_wp1_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          # periods = chosen_periods,
                          periods = chosen_periods_fmm,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier",
                                   "cbanker"))

coef_names_baseline <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'group_ident_broadhf' = 'High frequency', 
  'group_ident_broadnr' = 'Narrative',
  'group_ident_broadsignr' = 'Sign restrictions',
  'group_ident_broadidother' = 'Other identificiation ',
  'top_5_or_tier' = 'Top tier publication',
  'cbanker' = 'Central bank related')

# Create html output
modelsummary::modelsummary(pricelevel_wp1_baseline, 
                           output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

# For FMM presentation
modelsummary::modelsummary(pricelevel_wp1_baseline, 
                           output = "outputs_for_working_papers/wp1/discuss/baseline_meta_reg_pricelevel.png",
                           stars = TRUE, 
                           fmt = 2,
                           statistic = NULL,
                           conf_level = conflevel, 
                           gof_map = "nobs", 
                           coef_map = coef_names_baseline)

```

::: 

::: {.callout-note}
##### WP 1 Robustness: + estimation methods & outcome_measure

##### TO DO: 

```{r peese_pricelevel_ident_est_consolidated}
# Transform `outcome_measure_pricelevel` into factor and make "cpi" the reference
data <- data %>%
  mutate(outcome_measure_pricelevel = case_when(
    outcome == "inflation" ~ outcome_measure,
    TRUE ~ NA_character_  # For non-pricelevel rows
  )) %>% 
  mutate(outcome_measure_pricelevel = factor(outcome_measure_pricelevel, 
                                       levels = c("cpi", "deflator", "wpi", "core")))
             
pricelevel_wp1_baseline_robustness <- meta_analysis(data, 
                          outvar = out_var, 
                          se_option = "avg", 
                          # periods = chosen_periods,
                          periods = chosen_periods_fmm,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "group_est_broad",
                                   "bayes",
                                   "outcome_measure_pricelevel",
                                   "top_5_or_tier",
                                   "cbanker"))

coef_names_baseline <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'group_ident_broadhf' = 'High frequency', 
  'group_ident_broadnr' = 'Narrative',
  'group_ident_broadsignr' = 'Sign restrictions',
  'group_ident_broadidother' = 'Other identificiation ',
  'top_5_or_tier' = 'Top tier publication',
  'cbanker' = 'Central bank related',
  'group_est_broadlp_ardl' = 'LP and ARDL',
  'group_est_broadfavar' = 'FAVAR', 
  'group_est_broadother_var' = 'Other VAR',
  'group_est_broaddsge' = 'DSGE',
  'bayes' = 'Bayesian',
  'outcome_measure_pricelevelcore' = 'Core',
  'outcome_measure_priceleveldeflator' = 'Deflator',
  'outcome_measure_pricelevelwpi' = 'WPI')

# Create html output
modelsummary::modelsummary(pricelevel_wp1_baseline_robustness, 
                           output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

# For FMM presentation
modelsummary::modelsummary(pricelevel_wp1_baseline_robustness, 
                           output = "outputs_for_working_papers/wp1/discuss/robustness_meta_reg_pricelevel.tex",
                           stars = TRUE, 
                           fmt = 2,
                           statistic = NULL,
                           conf_level = conflevel, 
                           gof_map = "nobs", 
                           coef_map = coef_names_baseline)
```
:::


### Unemployment

```{r peese_unemp_ident_est_consolidated}

out_var <- "unemp"

unemp_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "group_est_broad",
                                   "bayes",
                                   # "outcome_measure", # Always une_rate
                                   "top_5_or_tier",
                                   "cbanker"))

coef_names_baseline <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'group_ident_broadhf' = 'High frequency', 
  'group_ident_broadnr' = 'Narrative',
  'group_ident_broadsignr' = 'Sign restrictions',
  'group_ident_broadidother' = 'Other identificiation ',
  'group_est_broadlp_ardl' = 'LP and ARDL',
  'group_est_broadfavar' = 'FAVAR', 
  'group_est_broadother_var' = 'Other VAR',
  'group_est_broaddsge' = 'DSGE',
  'bayes' = 'Bayesian',
  'top_5_or_tier' = 'Top tier publication',
  'cbanker' = 'Central bank related')

# Create html output
modelsummary::modelsummary(unemp_baseline, 
                           output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

```


### Employment

```{r peese_emp_ident_est_consolidated}

out_var <- "emp"

emp_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "group_est_broad",
                                   "bayes",
                                   "outcome_measure",
                                   "top_5_or_tier",
                                   "cbanker"))

coef_names_baseline <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'group_ident_broadhf' = 'High frequency', 
  'group_ident_broadnr' = 'Narrative',
  'group_ident_broadsignr' = 'Sign restrictions',
  'group_ident_broadidother' = 'Other identificiation ',
  'group_est_broadlp_ardl' = 'LP and ARDL',
  'group_est_broadfavar' = 'FAVAR', 
  'group_est_broadother_var' = 'Other VAR',
  'group_est_broaddsge' = 'DSGE',
  'bayes' = 'Bayesian',
  'outcome_measureemp_rate' = 'Emp. rate',
  'top_5_or_tier' = 'Top tier publication',
  'cbanker' = 'Central bank related')

# Create html output
modelsummary::modelsummary(emp_baseline, 
                           output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

```


::: {.callout-warning}
### Old version without `group_est_broad`, `outcome_measure` and `bayes` 

Baseline PEESE regression with moderators for `group_ident_broad`, `top_5_or_tier` and `cbanker`

::: {.callout-note}

This specification is motivated by our hypotheses about identification procedures (H7) and certain publication characteristics, like journal impact factors (H2) and central bank affiliation (H9).

:::

::: {.callout-important}
##### TO DO: Robustness

Add different specifications for these hypotheses.

Justifications for the baseline specification:

- simplicity (parsimonious specification) / avoiding too many variables in regression
- ...

:::

##### Output

```{r baseline_output_old}

out_var <- "output"

output_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier",
                                   "cbanker"))


coef_names_baseline <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'group_ident_broadhf' = 'High frequency', 
  'group_ident_broadnr' = 'Narrative',
  'group_ident_broadsignr' = 'Sign restrictions',
  'group_ident_broadidother' = 'Other identificiation ',
  'top_5_or_tier' = 'Top tier publication',
  'cbanker' = 'Central bank related')

# Create html output
modelsummary::modelsummary(output_baseline, 
                           output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

```


##### Price level

```{r baseline_pricelevel}

out_var<-"inflation"

pricelevel_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier",
                                   "cbanker"))#,"rate_pers"

# Create html output
modelsummary::modelsummary(pricelevel_baseline, output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

```

##### Unemployment

```{r baseline_unemployment}

out_var<-"unemp"

unemp_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier",
                                   "cbanker"))#,"rate_pers"

# Create html output
modelsummary::modelsummary(unemp_baseline, output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

```

##### Employment

```{r baseline_employment}

out_var<-"emp"

emp_baseline <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = "PEESE", 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier",
                                   "cbanker"))#,"rate_pers"

# Create html output
modelsummary::modelsummary(emp_baseline, output = "gt", stars = TRUE, conf_level = conflevel, title = paste0("PEESE ",out_var), gof_map = NULL, coef_map = coef_names_baseline)

```

::: 


## Robustness check for horizon 12 (PEESE)

### PEESE with moderators

```{r robustness_mods_prep}

# # Transform data$transformation to factor variable
# data$transformation <- as.factor(data$transformation)
# # Make "log" the reference transformation
# data <- within(data, transformation <- relevel(transformation, ref = 3))

# Transform data$transformed to factor variable 
data$transformed <- as.factor(data$transformed)

# Define robustness regression moderator terms 
# Baseline moderators
baseline_vars <- c("group_ident_broad", 
                   "top_5_or_tier", 
                   "cbanker")
# Interaction top journal & SE
interaction_top_5_tier_SE <- c("I(top_5_or_tier*standarderror_winsor)")
# Publication characteristics  
pub_chars <- c("pub_year", 
               "main_research_q")
# Transformation
transform_controls <- c("transformed", 
                        "cum")
# Model variables 
model_vars <- c("lrir", 
                "fx", 
                "foreignir", 
                "inflexp", 
                "eglob", 
                "find", 
                "outpgap", 
                "comprice")
# Estimation methods and sample characteristics
est_methods <- c("lp", 
                 "vecm", 
                 "dyn_ols", 
                 "fvar", 
                 "tvar", 
                 "gvar", 
                 "dsge", 
                 "varother", 
                 "panel", 
                 "bayes", 
                 "month", 
                 "mean_year", 
                 "ea12", 
                 "us", 
                 "upper_middle", 
                 "cut", 
                 "hike", 
                 "lor", 
                 "upr")


# Create list of different moderator sets for baseline and robustness checks
moderator_sets <- list(
  # Equation 1: Baseline
  baseline_vars,

  # Equation 1b: Baseline + interaction term (TopJournal*SE) for test of higher publication bias for top journals 
  c(baseline_vars, interaction_top_5_tier_SE),
  
  # Equation 2: Baseline + Publication characteristics
  c(baseline_vars, pub_chars),
  
  # Equation 3: Baseline + Publication characteristics + Transformation controls
  c(baseline_vars, pub_chars, transform_controls),
  
  # Equation 4: Baseline + Publication characteristics + Transformation controls + Model variables
  c(baseline_vars, pub_chars, transform_controls, model_vars),
  
  # Equation 5: Baseline + Publication characteristics + Transformation controls + Model variables + Estimation methods and sample characteristics
  c(baseline_vars, pub_chars, transform_controls, model_vars, est_methods)
)

```


#### Output

```{r robustness_output}

output_results_list <- list()

# Loop through the baseline and robustness moderator_sets
for (i in 1:length(moderator_sets)) {
    model <- meta_analysis(data, 
                           outvar = "output", 
                           se_option = "avg", # We should discuss this
                           periods = chosen_periods,
                           wins = wins_para, 
                           prec_weighted = TRUE, 
                           estimation = "PEESE", 
                           cluster_se = TRUE, 
                           mods = moderator_sets[[i]])
    if (i == 1) {
      output_results_list[[paste0("Baseline")]] <- model
    } else {
      output_results_list[[paste0("Robustness ", i-1)]] <- model
    }
    
}

# Define period for which all equations (baseline and robustness checks) should be shown
desired_period <- 12
index <- which(chosen_periods %in% desired_period)
paste("Showing results for period ", chosen_periods[index])

# Create html output
modelsummary::modelsummary(
  lapply(output_results_list, `[[`, index), 
  output = "gt", 
  stars = TRUE, 
  conf_level = conflevel, 
  title = paste0("PEESE (Output) period - ",desired_period), 
  gof_map = NULL) 

```

#### Price level

```{r robustness_pricelevel}

pricelevel_results_list <- list()

# Loop through the baseline and robustness moderator_sets
for (i in 1:length(moderator_sets)) {
    model <- meta_analysis(data, 
                           outvar = "inflation", 
                           se_option = "avg", # We should discuss this
                           periods = chosen_periods,
                           wins = wins_para, 
                           prec_weighted = TRUE, 
                           estimation = "PEESE", 
                           cluster_se = TRUE, 
                           mods = moderator_sets[[i]])
    if (i == 1) {
      pricelevel_results_list[[paste0("Baseline")]] <- model
    } else {
      pricelevel_results_list[[paste0("Robustness ", i-1)]] <- model
    }
    
}

# Define period for which all equations (baseline and robustness checks) should be shown
desired_period <- 12
index <- which(chosen_periods %in% desired_period)
paste("Showing results for period ", chosen_periods[index])

# Create html pricelevel
modelsummary::modelsummary(
  lapply(pricelevel_results_list, `[[`, index), 
  output = "gt", 
  stars = TRUE, 
  conf_level = conflevel, 
  title = paste0("PEESE (price level) period - ",desired_period), 
  gof_map = NULL
  ) 

```


#### Unemployment rate

```{r robustness_unemployment}

# For the unemployment, the data$transformed cannot be used as a moderator because there are only level estimations of the unemployment rate in our dataset:
data_unemp <- data %>% filter(outcome == "unemp")
unique(data_unemp$outcome_measure)
unique(data_unemp$transformed) # Has only one value ("no")
# Delete transformed from moderator list for unemployment
moderator_sets_unemp <- lapply(moderator_sets, function(set) {
  set[set != "transformed"]
})

unemployment_results_list <- list()

# Loop through the baseline and robustness moderator_sets_unemp
for (i in 1:length(moderator_sets_unemp)) {
    model <- meta_analysis(data, 
                           outvar = "unemp", 
                           se_option = "avg", # We should discuss this
                           periods = chosen_periods,
                           wins = wins_para, 
                           prec_weighted = TRUE, 
                           estimation = "PEESE", 
                           cluster_se = TRUE, 
                           mods = moderator_sets_unemp[[i]])
    if (i == 1) {
      unemployment_results_list[[paste0("Baseline")]] <- model
    } else {
      unemployment_results_list[[paste0("Robustness ", i-1)]] <- model
    }
    
}

# Define period for which all equations (baseline and robustness checks) should be shown
desired_period <- 12
index <- which(chosen_periods %in% desired_period)
paste("Showing results for period ", chosen_periods[index])

# Create html unemployment
modelsummary::modelsummary(
  lapply(unemployment_results_list, `[[`, index), 
  output = "gt", 
  stars = TRUE, 
  conf_level = conflevel, 
  title = paste0("PEESE (unemployment) period - ",desired_period), 
  gof_map = NULL
  ) 

```

#### Employment

```{r robustness_employment}

employment_results_list <- list()

# Loop through the baseline and robustness moderator_sets
for (i in 1:length(moderator_sets)) {
    model <- meta_analysis(data, 
                           outvar = "emp", 
                           se_option = "avg", # We should discuss this
                           periods = chosen_periods,
                           wins = wins_para, 
                           prec_weighted = TRUE, 
                           estimation = "PEESE", 
                           cluster_se = TRUE, 
                           mods = moderator_sets[[i]])
    if (i == 1) {
      employment_results_list[[paste0("Baseline")]] <- model
    } else {
      employment_results_list[[paste0("Robustness ", i-1)]] <- model
    }
    
}

# Define period for which all equations (baseline and robustness checks) should be shown
desired_period <- 12
index <- which(chosen_periods %in% desired_period)
paste("Showing results for period ", chosen_periods[index])

# Create html employment
modelsummary::modelsummary(
  lapply(employment_results_list, `[[`, index), 
  output = "gt", 
  stars = TRUE, 
  conf_level = conflevel, 
  title = paste0("PEESE (employment) period - ",desired_period), 
  gof_map = NULL
  ) 

```

## Bayesian model averaging 


::: {.callout-tip}

TO DO: are these comments still valid?

- In this section, results are need to be updated manually due to intensity of calculation.
- For the large plots, try right click in browser to open pictures in a new tab for more details.

:::

### Output 

#### All data, no winsorization, __in__cluding `quality_concern` 

::: {.callout-note}
As a first exploration of heterogeneity and its associated covariates in our coding, we estimate a broad range of models on our full sample. This also reveals the inflating influence of studies with `quality_concern`s on the `mean.effect`.
:::

::: {.callout-important}
TO DO: define function for bma with data as input
:::

- no se 
- no external data
- mostly raw coding data

```{r bma_broad_output}
#| eval: false
out_var <- "output"

# Define periods for which BMA should be done
bma_periods <- c(3, 6, 12, 18, 24, 30, 36, 48)

for (x in bma_periods) {
  
  # Filter data for out_var and the current period x
  data_bma <- data_with_quality_concern %>% 
    filter(outcome == out_var, period.month == x) %>% 
    mutate(         
      abs_shock_size = abs(shock_size) # This should enter with absolute value, since mean.effect is standardized. We could also do this in data_prep.
      ) %>% 
    select(
        mean.effect,
        cum,
        prefer,
        abs_shock_size,
        # Identification
        iv,
        forecast_based,
        nr,
        event,
        chol,
        svar,
        signr,
        hf,
        heteroskedas,
        longrun,
        idother,
        # Estimation method
        var,
        lp,
        vecm,
        dyn_ols,
        fvar,
        tvar,
        gvar,
        bayes,
        dsge,
        varother,
        ## Regime
        # lor,
        # upr,
        # scr,                        # this is 0 for all models
        # dcr,                        # this is 0 for all models
        # hike,
        # cut,
        # Frequency
        # annual,                      # This needs to be deactivated for non-year months
        # quarter,                     # Needs to be deactivated for 6 months
        # month,
        ## Other data characteristics
        # panel,
        # observations,                  # Maybe rather take the log here already
        ## Controls
        # comprice,
        # outpgap,
        # find,
        # eglob,
        # cbind#,                           # this is zero for all studies
        # fexch,
        # inflexp,
        # foreignir,
        # fx,
        # lrir,
        ## Other
        # pure_rate_shock,
        # convent,
        # decomposition,
        # cbanker,
        # pub_year,                     
        # transformation,
        # periodicity,
        # real_output,                   # Real output might not be consistent in coding (gdp vs rgdp)
        # outcome_measure,
        # transformed,                   # Try alternatively with transformation
        # main_research_q,
        # quality_concern,
        # regime,
        # rate_pers, # Try this one with complete.cases below (it should work, but seems to interfere with some other variable, try different versions)
        # country_dev,         # Try as alternative to advanced, upper_middle, mixed
        # advanced,
        # upper_middle,
        # mixed_unclass,
        # interest_rate_short,
        # start_year,                     # Maybe use as alternative to mean_year
        # end_year,                       # Maybe use as alternative to mean_year
        # mean_year
    )
  
  # Automatically create dummies for factor and character variables.
  # This sets as reference group the most frequent level of each factor variable
  # and removes the original factor variable to only use the newly created dummies. 
  # data_bma <- fastDummies::dummy_cols(data_bma,
  #                                     remove_most_frequent_dummy = TRUE,
  #                                     remove_selected_columns = TRUE)
  
  # Test if any NA values in data_bma and remove these
  if (anyNA(data_bma)) {
    warning("Some of the selected variables contain NA values. Bayesian model averaging will ignore these observations.")
    data_bma <- data_bma[complete.cases(data_bma), ]
  }
  
  # BMS package requires a dataframe
  data_bma <- as.data.frame(data_bma)
  
  # Estimation
  bma_broad_output <- BMS::bms(data_bma, 
             g = "UIP", 
             mprior = "uniform", 
             user.int = FALSE,
             nmodel = 5000,
             burn = 1e5, # 1e6, # burn ins and iterations should be increased for final estimation
             iter= 2e5,  # 2e6, # burn ins and iterations should be increased for final estimation
             mcmc="bd")
  
  # Model summary
  summary(bma_broad_output)
  
  # 
  subtitle <- paste("Period ", x)
  image(bma_broad_output, 
        yprop2pip = FALSE, 
        cex.axis=.4, 
        sub = subtitle
  )

  
}
```

```{r}

out_var <- "output"

# Define periods for which BMA should be done
bma_periods <- c(3, 6, 12, 18, 24, 30, 36, 48)


# Initialize a list to store error messages
error_log <- list()

# Initialize a list to store successful outputs
bma_outputs <- list()

for (x in bma_periods) {
  tryCatch({
    # Filter data for out_var and the current period x
    data_bma <- data_with_quality_concern %>% 
      filter(outcome == out_var, period.month == x) %>% 
      mutate(         
        abs_shock_size = abs(shock_size)
      ) %>% 
      select(
        mean.effect,
        cum,
        prefer,
        abs_shock_size,
        # Identification
        iv,
        forecast_based,
        nr,
        event,
        chol,
        svar,
        signr,
        hf,
        heteroskedas,
        longrun,
        idother,
        # Estimation method
        var,
        lp,
        vecm,
        dyn_ols,
        fvar,
        tvar,
        gvar,
        bayes,
        dsge,
        varother,
        # Regime
        lor,
        upr,
        # scr,                        # this is 0 for all models
        # dcr,                        # this is 0 for all models
        hike,
        cut,
        # Frequency
        # annual,                      # This needs to be deactivated for non-year months
        # quarter,                     # Needs to be deactivated for 6 months
        month,
        # Other data characteristics
        panel,
        observations,                  # Maybe rather take the log here already
        # Controls
        comprice,
        outpgap,
        find,
        eglob,
        # cbind#,                           # this is zero for all studies
        fexch,
        inflexp,
        foreignir,
        fx,
        lrir,
        # Other
        pure_rate_shock,
        convent,
        decomposition,
        cbanker,
        pub_year,
        transformation,
        periodicity,
        # real_output,                   # Real output might not be consistent in coding (gdp vs rgdp)
        outcome_measure,
        # transformed,                   # Try alternatively with transformation
        main_research_q,
        quality_concern,
        regime,
        # rate_pers, # Try this one with complete.cases below (it should work, but seems to interfere with some other variable, try different versions)
        # country_dev,         # Try as alternative to advanced, upper_middle, mixed
        advanced,
        upper_middle,
        mixed_unclass,
        interest_rate_short,
        start_year,                     # Maybe use as alternative to mean_year
        end_year,                       # Maybe use as alternative to mean_year
        mean_year
    )
    
    # Automatically create dummies for factor and character variables.
    # This sets as reference group the most frequent level of each factor variable
    # and removes the original factor variable to only use the newly created dummies. 
    data_bma <- fastDummies::dummy_cols(data_bma,
                                        remove_most_frequent_dummy = TRUE,
                                        remove_selected_columns = TRUE)
    
    # Test if any NA values in data_bma and remove these
    if (anyNA(data_bma)) {
      warning("Some of the selected variables contain NA values. Bayesian model averaging will ignore these observations.")
      data_bma <- data_bma[complete.cases(data_bma), ]
    }
    
    # BMS package requires a dataframe
    data_bma <- as.data.frame(data_bma)
    
    # Estimation
    bma_broad_output <- BMS::bms(data_bma, 
               g = "UIP", 
               mprior = "uniform", 
               user.int = FALSE,
               nmodel = 5000,
               burn = 1e4,
               iter = 2e4,
               mcmc = "bd")
    
    # Store the successful output
    bma_outputs[[as.character(x)]] <- bma_broad_output
    
    # Model summary
    summary(bma_broad_output)
    
    # Plot
    subtitle <- paste("Period ", x)
    image(bma_broad_output, 
          yprop2pip = FALSE, 
          cex.axis = .2, 
          sub = subtitle
    )
    
  }, error = function(e) {
    # Store the error message along with the iteration info
    error_log[[length(error_log) + 1]] <- conditionMessage(e)
    
  })
}

# You can also check which periods were successfully processed
successful_periods <- names(bma_outputs)
print(paste("Successfully processed periods:", paste(successful_periods, collapse = ", ")))
```


#### All data, 2 % winsorization, __ex__cluding `quality_concern` 

- no se 
- no external data
- as raw coding data as possible

```{r}
# data_bms <- 
  
```

# Best practices and high quality estimation

## High quality estimation

### Conservative high quality PEESE


::: {.callout-note}

- No basic Cholecki/SVAR
- no DSGE
- only conventional MP
- PEESE

(try also inclusion of "outpgap", has strong effect on IRF)
:::

::: {.callout-warning}

Note: DSGE models in our data never have effect sizes in period 0 or 1. Can this be true? We should check this.

```{r}

dsge_1 <- data %>% filter(dsge == 1, period.month == 1)
head(dsge_1)
```

:::

#### Output

```{r conservative_high_quality_output}

# Create basic Cholecki/SVAR dummy
data <- data %>%
  mutate(basic_chol_svar = ifelse(group_ident_broad == "chol", 1, 0))
out_var <- "output"
method <- "PEESE" # try also FAT-PET
# Estimate
output_cons_hq <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c("basic_chol_svar",
                                   # "outpgap", has strong effect on IRF
                                   "dsge",
                                   "convent"))

coef_names_cons_hq <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'basic_chol_svar' = 'Basic Cholecki or SVAR', 
  # "outpgap" = "outpgap", # has strong effect on IRF
  'dsge' = 'DSGE',
  'convent' = 'Conventional MP')

cons_hq_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # Basic Cholecki or SVAR
  # 1, # outpgap # has strong effect on IRF
  0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(output_cons_hq, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_cons_hq)

output_cons_hq_results <- list()

# Loop through each period's model
for (i in seq_along(output_cons_hq)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(output_cons_hq[[i]]))
  
  # Perform matrix multiplication
  result <- cons_hq_coef_selection %*% betahat
  
  # Store the result in the list
  output_cons_hq_results[[i]] <- result
}

output_cons_hq_results <- do.call(rbind, lapply(output_cons_hq_results, as.data.frame))
output_cons_hq_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_cons_hq <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = output_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_cons_hq
```

#### Price level

```{r conservative_high_quality_pricelevel}

out_var <- "inflation"
method <- "PEESE" # try also FAT-PET
# Estimate
pricelevel_cons_hq <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c("basic_chol_svar",
                                   "dsge",
                                   # "outpgap", # has strong effect on IRF
                                   "convent"))

coef_names_cons_hq <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'basic_chol_svar' = 'Basic Cholecki or SVAR', 
  'dsge' = 'DSGE',
  # "outpgap", # has strong effect on IRF
  'convent' = 'Conventional MP')

cons_hq_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # Basic Cholecki or SVAR
  0, # DSGE
  # 1, # "outpgap", has strong effect on IRF
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(pricelevel_cons_hq, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_cons_hq)

pricelevel_cons_hq_results <- list()

# Loop through each period's model
for (i in seq_along(pricelevel_cons_hq)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(pricelevel_cons_hq[[i]]))
  
  # Perform matrix multiplication
  result <- cons_hq_coef_selection %*% betahat
  
  # Store the result in the list
  pricelevel_cons_hq_results[[i]] <- result
}

pricelevel_cons_hq_results <- do.call(rbind, lapply(pricelevel_cons_hq_results, as.data.frame))
pricelevel_cons_hq_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_cons_hq <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = pricelevel_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_cons_hq
```


#### Unemployment

::: {.callout-note}

For unemployment, including `basic_chol_svar` and `dsge` in the regression does not work. So conservative high quality here is only:

- only conventional MP
- PEESE

:::

```{r conservative_high_quality_unemp}

out_var <- "unemp"
method <- "PEESE"
# Estimate
unemp_cons_hq <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(#"basic_chol_svar",
                                   # "dsge",
                                   "convent"))

coef_names_cons_hq <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  # 'basic_chol_svar' = 'Basic Cholecki or SVAR', 
  # 'dsge' = 'DSGE',
  'convent' = 'Conventional MP')

cons_hq_coef_selection <-c(
  1, # Intercept
  0, # Variance
  # 0, # Basic Cholecki or SVAR
  # 0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(unemp_cons_hq, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_cons_hq)

unemp_cons_hq_results <- list()

# Loop through each period's model
for (i in seq_along(unemp_cons_hq)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(unemp_cons_hq[[i]]))
  
  # Perform matrix multiplication
  result <- cons_hq_coef_selection %*% betahat
  
  # Store the result in the list
  unemp_cons_hq_results[[i]] <- result
}

unemp_cons_hq_results <- do.call(rbind, lapply(unemp_cons_hq_results, as.data.frame))
unemp_cons_hq_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_cons_hq <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = unemp_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_cons_hq
```

#### Employment

::: {.callout-note}

For unemployment, including `dsge` in the regression does not work. So conservative high quality here is only:

- No basic Cholecki/SVAR
- only conventional MP
- PEESE

:::

```{r conservative_high_quality_emp}

out_var <- "emp"
method <- "PEESE"
# Estimate
emp_cons_hq <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c("basic_chol_svar",
                                   # "dsge",
                                   "convent"))

coef_names_cons_hq <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'basic_chol_svar' = 'Basic Cholecki or SVAR', 
  'dsge' = 'DSGE',
  'convent' = 'Conventional MP')

cons_hq_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # Basic Cholecki or SVAR
  # 0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(emp_cons_hq, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_cons_hq)

emp_cons_hq_results <- list()

# Loop through each period's model
for (i in seq_along(emp_cons_hq)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(emp_cons_hq[[i]]))
  
  # Perform matrix multiplication
  result <- cons_hq_coef_selection %*% betahat
  
  # Store the result in the list
  emp_cons_hq_results[[i]] <- result
}

emp_cons_hq_results <- do.call(rbind, lapply(emp_cons_hq_results, as.data.frame))
emp_cons_hq_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_cons_hq <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = emp_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_cons_hq
```

#### Interest rate

```{r conservative_high_quality_rate}

out_var <- "rate"
method <- "PEESE"
# Estimate
rate_cons_hq <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c("basic_chol_svar",
                                   "dsge",
                                   "convent"))

coef_names_cons_hq <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'basic_chol_svar' = 'Basic Cholecki or SVAR', 
  'dsge' = 'DSGE',
  'convent' = 'Conventional MP')

cons_hq_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # Basic Cholecki or SVAR
  0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(rate_cons_hq, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL, 
                           coef_map = coef_names_cons_hq)

rate_cons_hq_results <- list()

# Loop through each period's model
for (i in seq_along(rate_cons_hq)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(rate_cons_hq[[i]]))
  
  # Perform matrix multiplication
  result <- cons_hq_coef_selection %*% betahat
  
  # Store the result in the list
  rate_cons_hq_results[[i]] <- result
}

rate_cons_hq_results <- do.call(rbind, lapply(rate_cons_hq_results, as.data.frame))
rate_cons_hq_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_cons_hq <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = rate_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_cons_hq
```

### Broad high quality

::: {.callout-note}

- only hf and nr
- only top_5_or_tier
- latest publication year
- only main research question
- only log levels
- no TVP-VAR
- no DSGE
- only conventional MP
- PEESE

:::

#### Output

```{r broad_high_quality_output}

# Create non hf-non-nr dummy
data <- data %>%
  mutate(no_hf_no_nr = ifelse(!group_ident_broad %in% c("hf", "nr"), 1, 0))
# Create publication year variable that implies most recent publication year if == 0
data$pub_year_0 <- data$pub_year - max(data$pub_year)

out_var <- "output"
method <- "PEESE"
# Estimate
output_broad_hq <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            "no_hf_no_nr", # 0
                            "top_5_or_tier", # 1
                            "pub_year_0", # 0
                            "main_research_q", # 1
                            "transformed", # 0
                            "tvar", # 0 
                            "dsge", # 0 
                            # "outpgap", # has strong effect on IRF
                            "convent") # 1 
)

broad_hq_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # no_hf_no_nr
  1, # top_5_or_tier
  0, # pub_year_0
  1, # main_research_q
  0, # transformed
  0, # TVP-VAR
  0, # DSGE
  # 1, # "outpgap", # has strong effect on IRF
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(output_broad_hq, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

output_broad_hq_results <- list()

# Loop through each period's model
for (i in seq_along(output_broad_hq)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(output_broad_hq[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_coef_selection %*% betahat
  
  # Store the result in the list
  output_broad_hq_results[[i]] <- result
}

output_broad_hq_results <- do.call(rbind, lapply(output_broad_hq_results, as.data.frame))
output_broad_hq_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = output_broad_hq_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq
```


::: {.callout-note}

Here, we drop the top_5_or_tier dummy from regression.

- only hf and nr
<!-- - only top_5_or_tier -->
- latest publication year
- only main research question
- only log levels
- no TVP-VAR
- no DSGE
- only conventional MP
- PEESE

:::

```{r broad_high_quality_output_2}

# Estimate
output_broad_hq_2 <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            "no_hf_no_nr", # 0
                            # "top_5_or_tier", # 1
                            "pub_year_0", # 0
                            "main_research_q", # 1
                            "transformed", # 0
                            "tvar", # 0 
                            "dsge", # 0 
                            "convent") # 1 
)

broad_hq_2_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # no_hf_no_nr
  # 1, # top_5_or_tier
  0, # pub_year_0
  1, # main_research_q
  0, # transformed
  0, # TVP-VAR
  0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(output_broad_hq_2, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

output_broad_hq_2_results <- list()

# Loop through each period's model
for (i in seq_along(output_broad_hq_2)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(output_broad_hq_2[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_2_coef_selection %*% betahat
  
  # Store the result in the list
  output_broad_hq_2_results[[i]] <- result
}

output_broad_hq_2_results <- do.call(rbind, lapply(output_broad_hq_2_results, as.data.frame))
output_broad_hq_2_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq_2 <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = output_broad_hq_2_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without top_5_or_tier)",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq_2
```

::: {.callout-note}

Here, we drop the pub_year_0 dummy from regression.

- only hf and nr
- only top_5_or_tier
<!-- - latest publication year -->
- only main research question
- only log levels
- no TVP-VAR
- no DSGE
- only conventional MP
- PEESE

:::

```{r broad_high_quality_output_3}

# Estimate
output_broad_hq_3 <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            "no_hf_no_nr", # 0
                            "top_5_or_tier", # 1
                            # "pub_year_0", # 0
                            "main_research_q", # 1
                            "transformed", # 0
                            "tvar", # 0 
                            "dsge", # 0 
                            "convent") # 1 
)

broad_hq_3_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # no_hf_no_nr
  1, # top_5_or_tier
  # 0, # pub_year_0
  1, # main_research_q
  0, # transformed
  0, # TVP-VAR
  0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(output_broad_hq_3, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

output_broad_hq_3_results <- list()

# Loop through each period's model
for (i in seq_along(output_broad_hq_3)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(output_broad_hq_3[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_3_coef_selection %*% betahat
  
  # Store the result in the list
  output_broad_hq_3_results[[i]] <- result
}

output_broad_hq_3_results <- do.call(rbind, lapply(output_broad_hq_3_results, as.data.frame))
output_broad_hq_3_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq_3 <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = output_broad_hq_3_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without pub_year_0)",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq_3
```

::: {.callout-note}

Here, we drop all except `no_hf_no_nr` from regression.

- only hf and nr
<!-- - only top_5_or_tier -->
<!-- - latest publication year -->
<!-- - only main research question -->
<!-- - only log levels -->
<!-- - no TVP-VAR -->
<!-- - no DSGE -->
<!-- - only conventional MP -->
- PEESE

:::

```{r broad_high_quality_output_4}

# Estimate
output_broad_hq_4 <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            "no_hf_no_nr")#, # 0
                            # "top_5_or_tier", # 1
                            # "pub_year_0", # 0
                            # "main_research_q", # 1
                            # "transformed", # 0
                            # "tvar", # 0 
                            # "dsge", # 0 
                            # "convent") # 1 
)

broad_hq_4_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0)#, # no_hf_no_nr
  # 1, # top_5_or_tier
  # 0, # pub_year_0
  # 1, # main_research_q
  # 0, # transformed
  # 0, # TVP-VAR
  # 0, # DSGE
  # 1) # Conventional MP

# Create html output
modelsummary::modelsummary(output_broad_hq_4, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

output_broad_hq_4_results <- list()

# Loop through each period's model
for (i in seq_along(output_broad_hq_4)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(output_broad_hq_4[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_4_coef_selection %*% betahat
  
  # Store the result in the list
  output_broad_hq_4_results[[i]] <- result
}

output_broad_hq_4_results <- do.call(rbind, lapply(output_broad_hq_4_results, as.data.frame))
output_broad_hq_4_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq_4 <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = output_broad_hq_4_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (only with no_hf_no_nr)",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq_4
```

#### Price level 

```{r broad_high_quality_pricelevel}

# Create non hf-non-nr dummy
data <- data %>%
  mutate(no_hf_no_nr = ifelse(!group_ident_broad %in% c("hf", "nr"), 1, 0))
# Create publication year variable that implies most recent publication year if == 0
data$pub_year_0 <- data$pub_year - max(data$pub_year)

out_var <- "inflation"
method <- "PEESE"
# Estimate
pricelevel_broad_hq <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            "no_hf_no_nr", # 0
                            "top_5_or_tier", # 1
                            "pub_year_0", # 0
                            "main_research_q", # 1
                            "transformed", # 0
                            "tvar", # 0 
                            "dsge", # 0 
                            # "outpgap", # has strong effect on IRF
                            "convent") # 1 
)

broad_hq_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # no_hf_no_nr
  1, # top_5_or_tier
  0, # pub_year_0
  1, # main_research_q
  0, # transformed
  0, # TVP-VAR
  0, # DSGE
  # 1, # "outpgap", # has strong effect on IRF
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(pricelevel_broad_hq, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

pricelevel_broad_hq_results <- list()

# Loop through each period's model
for (i in seq_along(pricelevel_broad_hq)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(pricelevel_broad_hq[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_coef_selection %*% betahat
  
  # Store the result in the list
  pricelevel_broad_hq_results[[i]] <- result
}

pricelevel_broad_hq_results <- do.call(rbind, lapply(pricelevel_broad_hq_results, as.data.frame))
pricelevel_broad_hq_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = pricelevel_broad_hq_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq
```


::: {.callout-note}

Here, we drop the top_5_or_tier dummy from regression.

- only hf and nr
<!-- - only top_5_or_tier -->
- latest publication year
- only main research question
- only log levels
- no TVP-VAR
- no DSGE
- only conventional MP
- PEESE

:::

```{r broad_high_quality_pricelevel_2}

# Estimate
pricelevel_broad_hq_2 <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            "no_hf_no_nr", # 0
                            # "top_5_or_tier", # 1
                            "pub_year_0", # 0
                            "main_research_q", # 1
                            "transformed", # 0
                            "tvar", # 0 
                            "dsge", # 0 
                            "convent") # 1 
)

broad_hq_2_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # no_hf_no_nr
  # 1, # top_5_or_tier
  0, # pub_year_0
  1, # main_research_q
  0, # transformed
  0, # TVP-VAR
  0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(pricelevel_broad_hq_2, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

pricelevel_broad_hq_2_results <- list()

# Loop through each period's model
for (i in seq_along(pricelevel_broad_hq_2)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(pricelevel_broad_hq_2[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_2_coef_selection %*% betahat
  
  # Store the result in the list
  pricelevel_broad_hq_2_results[[i]] <- result
}

pricelevel_broad_hq_2_results <- do.call(rbind, lapply(pricelevel_broad_hq_2_results, as.data.frame))
pricelevel_broad_hq_2_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq_2 <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = pricelevel_broad_hq_2_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without top_5_or_tier)",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq_2
```

::: {.callout-note}

Here, we drop the pub_year_0 dummy from regression.

- only hf and nr
- only top_5_or_tier
<!-- - latest publication year -->
- only main research question
- only log levels
- no TVP-VAR
- no DSGE
- only conventional MP
- PEESE

:::

```{r broad_high_quality_pricelevel_3}

# Estimate
pricelevel_broad_hq_3 <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            "no_hf_no_nr", # 0
                            "top_5_or_tier", # 1
                            # "pub_year_0", # 0
                            "main_research_q", # 1
                            "transformed", # 0
                            "tvar", # 0 
                            "dsge", # 0 
                            "convent") # 1 
)

broad_hq_3_coef_selection <-c(
  1, # Intercept
  0, # Variance
  0, # no_hf_no_nr
  1, # top_5_or_tier
  # 0, # pub_year_0
  1, # main_research_q
  0, # transformed
  0, # TVP-VAR
  0, # DSGE
  1) # Conventional MP

# Create html output
modelsummary::modelsummary(pricelevel_broad_hq_3, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

pricelevel_broad_hq_3_results <- list()

# Loop through each period's model
for (i in seq_along(pricelevel_broad_hq_3)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(pricelevel_broad_hq_3[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_3_coef_selection %*% betahat
  
  # Store the result in the list
  pricelevel_broad_hq_3_results[[i]] <- result
}

pricelevel_broad_hq_3_results <- do.call(rbind, lapply(pricelevel_broad_hq_3_results, as.data.frame))
pricelevel_broad_hq_3_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq_3 <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = pricelevel_broad_hq_3_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without pub_year_0)",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq_3
```

::: {.callout-note}

Here, we drop all except `no_hf_no_nr` from regression.

- only hf and nr
<!-- - only top_5_or_tier -->
<!-- - latest publication year -->
<!-- - only main research question -->
<!-- - only log levels -->
<!-- - no TVP-VAR -->
<!-- - no DSGE -->
<!-- - only conventional MP -->
- PEESE

:::

```{r broad_high_quality_pricelevel_4}

# Estimate
pricelevel_broad_hq_4 <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c(
                            # "outpgap", # has strong effect on IRF
                            "no_hf_no_nr")#, # 0
                            # "top_5_or_tier", # 1
                            # "pub_year_0", # 0
                            # "main_research_q", # 1
                            # "transformed", # 0
                            # "tvar", # 0 
                            # "dsge", # 0 
                            # "convent") # 1 
)

broad_hq_4_coef_selection <-c(
  1, # Intercept
  0, # Variance
  # 1, # "outpgap", # has strong effect on IRF
  0)#, # no_hf_no_nr
  # 1, # top_5_or_tier
  # 0, # pub_year_0
  # 1, # main_research_q
  # 0, # transformed
  # 0, # TVP-VAR
  # 0, # DSGE
  # 1) # Conventional MP

# Create html output
modelsummary::modelsummary(pricelevel_broad_hq_4, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

pricelevel_broad_hq_4_results <- list()

# Loop through each period's model
for (i in seq_along(pricelevel_broad_hq_4)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(pricelevel_broad_hq_4[[i]]))
  
  # Perform matrix multiplication
  result <- broad_hq_4_coef_selection %*% betahat
  
  # Store the result in the list
  pricelevel_broad_hq_4_results[[i]] <- result
}

pricelevel_broad_hq_4_results <- do.call(rbind, lapply(pricelevel_broad_hq_4_results, as.data.frame))
pricelevel_broad_hq_4_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_broad_hq_4 <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = pricelevel_broad_hq_4_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (only with no_hf_no_nr)",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_broad_hq_4
```


#### Unemployment rate

#### Employment

#### Interest rate

### ME best practice 1

#### Output

```{r me_bp_output}

out_var <- "output"
method <- "FAT-PET"
# Estimate
wins_para <- 0.02
output_me_bp <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier", 
                                   "cbanker",
                                   "pub_year", 
                                   "main_research_q", 
                                   "transformed", 
                                   "cum", 
                                   "lrir", 
                                   "fx", 
                                   "foreignir", 
                                   "inflexp", 
                                   "eglob", 
                                   "find", 
                                   "outpgap", 
                                   "comprice",
                                   "lp", 
                                   "vecm",
                                   # "dyn_ols",
                                   "fvar", 
                                   "tvar", 
                                   "gvar", 
                                   "dsge", 
                                   "varother", 
                                   "panel", 
                                   "bayes",
                                   "convent"))

coef_names_cons_hq <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'basic_chol_svar' = 'Basic Cholecki or SVAR', 
  'dsge' = 'DSGE',
  'convent' = 'Conventional MP')

cons_hq_coef_selection <-
me_best_pract <- c(1,0,1,0,0,0,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1)


# Create html output
modelsummary::modelsummary(output_me_bp, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

output_me_bp_results <- list()

# Loop through each period's model
for (i in seq_along(output_me_bp)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(output_me_bp[[i]]))
  
  # Perform matrix multiplication
  result <- cons_hq_coef_selection %*% betahat
  
  # Store the result in the list
  output_me_bp_results[[i]] <- result
}

output_me_bp_results <- do.call(rbind, lapply(output_me_bp_results, as.data.frame))
output_me_bp_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_output_me_bp <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = output_me_bp_results,
    x = ~period,
    y = ~V1,
    name = "ME bp",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_output_me_bp
```

#### Price level

```{r me_bp_pricelevel}

out_var <- "inflation"
method <- "FAT-PET"
# Estimate
wins_para <- 0.02
pricelevel_me_bp <- meta_analysis(data , 
                          outvar = out_var, 
                          se_option = "avg", 
                          periods = chosen_periods,
                          wins = wins_para, 
                          prec_weighted = TRUE, 
                          estimation = method, 
                          cluster_se = TRUE, 
                          mods = c("group_ident_broad",
                                   "top_5_or_tier", 
                                   "cbanker",
                                   "pub_year", 
                                   "main_research_q", 
                                   "transformed", 
                                   "cum", 
                                   "lrir", 
                                   "fx", 
                                   "foreignir", 
                                   "inflexp", 
                                   "eglob", 
                                   "find", 
                                   "outpgap", 
                                   "comprice",
                                   "lp", 
                                   "vecm",
                                   # "dyn_ols",
                                   "fvar", 
                                   "tvar", 
                                   "gvar", 
                                   "dsge", 
                                   "varother", 
                                   "panel", 
                                   "bayes",
                                   "convent"))

coef_names_cons_hq <- c(
  "(Intercept)"="Intercept",
  "variance_winsor"= "Variance",
  'basic_chol_svar' = 'Basic Cholecki or SVAR', 
  'dsge' = 'DSGE',
  'convent' = 'Conventional MP')

cons_hq_coef_selection <-
me_best_pract <- c(1,0,1,0,0,0,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1)


# Create html output
modelsummary::modelsummary(pricelevel_me_bp, 
                           output = "gt", 
                           stars = TRUE, 
                           conf_level = conflevel, 
                           title = paste0(method, out_var), 
                           gof_map = NULL)

pricelevel_me_bp_results <- list()

# Loop through each period's model
for (i in seq_along(pricelevel_me_bp)) {
  # Extract coefficients as a matrix
  betahat <- as.matrix(coef(pricelevel_me_bp[[i]]))
  
  # Perform matrix multiplication
  result <- cons_hq_coef_selection %*% betahat
  
  # Store the result in the list
  pricelevel_me_bp_results[[i]] <- result
}

pricelevel_me_bp_results <- do.call(rbind, lapply(pricelevel_me_bp_results, as.data.frame))
pricelevel_me_bp_results$period <- seq(3, 60, by = 3)

# Generate the average IRF plot with PEESE correction
irf_pricelevel_me_bp <- plot_average_irfs(
  data %>% filter(period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL
) %>%
  add_lines(
    data = pricelevel_me_bp_results,
    x = ~period,
    y = ~V1,
    name = "ME bp",
    line = list(color = 'rgba(100,100,100,1)')
  ) 

irf_pricelevel_me_bp
```

#### Unemployment rate

#### Employment

#### Interest rate

# Range of IRF corrections

## Output

### With sampling

::: {.callout-warning}

This version has unstable results due to drawing samples but much faster estimation.

:::

```{r output_irf_correction_range}

# Filter the data
out_var <- "output"
filtered_data <- data %>%
  filter(!quality_concern, period.month %in% seq(0,60, by = 3), outcome == out_var)#, us==1


# Set up winsorization levels for estimations
wins_para_levels <- c(0,0.01, 0.02, 0.03, 0.04)
conf_lev <- 0.89

# Function to perform meta-analysis for a given wins level
perform_meta_analysis <- function(data, wins) {
  list(
    peese = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      ap = FALSE,
      prec_weighted = TRUE,
      estimation = "PEESE",
      cluster_se = TRUE
    ),
    waap = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      ap = TRUE,
      prec_weighted = FALSE,
      estimation = "UWLS",
      cluster_se = TRUE
      ),
    AK = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      prec_weighted = FALSE,
      estimation = "AK",
      cluster_se = TRUE,
      cutoff_val=1,
      AK_modelmu = "t",
      AK_symmetric = FALSE,
      AK_conf_level = 0.68,
      ak_plot = "both"
  )
  )
}


# Function to extract intercepts
extract_intercepts <- function(model, method) {
  if (method == "AK") {
    estimate <- model$tidy[1, 2]
    se <- model$tidy[1, 3]
    ci_lower <- estimate - se * qnorm(1 - (1 - conf_lev) / 2)
    ci_upper <- estimate + se * qnorm(1 - (1 - conf_lev) / 2)
  } else {
    ci <- confint(model, level = conf_lev)
    estimate <- unname(coef(model)[1])
    ci_lower <- unname(ci[1, 1])
    ci_upper <- unname(ci[1, 2])
  }
  return(c(estimate = estimate, lower = ci_lower, upper = ci_upper))
}


# Function to combine results
combine_results <- function(results_list, method_name) {
  lapply(names(results_list), function(wins_name) {
    results <- results_list[[wins_name]][[method_name]]
    intercepts <- lapply(results, extract_intercepts, method = method_name)
    df <- do.call(rbind, intercepts)
    df <- as.data.frame(df)
    df$period <- as.numeric(rownames(df))
    df$wins_para <- wins_name
    df$method <- method_name
    return(df)
  })
}


analyze_subsample <- function(subsample_id) {#, us_value, group_value
  # Filter data based on 'us' and 'group_ident_broad' values
  subsample <- filtered_data %>%
    #filter(us == us_value, group_ident_broad != group_value) %>%
    group_by(key, period.month) %>%
    sample_n(size = 1, replace = FALSE) %>%
    ungroup()  # Adjust sample size as needed
  
  results_list <- lapply(wins_para_levels, function(wins) perform_meta_analysis(subsample, wins))
  names(results_list) <- paste0("wins_", wins_para_levels)
  
  # Combine results for all methods
  final_peese <- do.call(rbind, combine_results(results_list, "peese"))
  final_waap <- do.call(rbind, combine_results(results_list, "waap"))
  final_ak <- do.call(rbind, combine_results(results_list, "AK"))
  
  # Combine all method results into a single final data frame
  final_df <- rbind(final_peese, final_waap, final_ak)
  final_df$subsample <- subsample_id
  # final_df$us <- us_value
  # final_df$group_ident_broad <- group_value
  
  return(final_df)
}

# Initialize a list to store results
all_results <- list()

# Compute results using the functions from above
results <- lapply(1:10, analyze_subsample)
  

# Combine results for all subsamples
all_results_df <- do.call(rbind, results)

# Use 95%  region of estimate per period. 
min_max_per_period <- all_results_df %>%
  group_by(period) %>%
  summarise(
    min_estimate = quantile(estimate,0.025, na.rm = TRUE),
    max_estimate = quantile(estimate,0.975, na.rm = TRUE)
  ) %>% ungroup()


# Generate the average IRF plot with PEESE correction
irf_range_correction <- plot_average_irfs(
  filtered_data,
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = T
)  %>%
  add_ribbons(
    data = min_max_per_period,
    x = ~period,
    ymin = ~min_estimate,
    ymax = ~max_estimate,
    name = "P-bias correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(100,20,200,0.2)'
  ) %>%
  layout(
    title = "Output response to 100 bp rate shock, average and p-bias corrected range",
    xaxis = list(title = "Month"),
    yaxis = list(title = "Effect in %"),
    hovermode = "compare"
  )

irf_range_correction

irf_range_correction %>%
  add_lines(
    data = output_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  )
irf_range_correction%>%
  add_lines(
    data = output_me_bp_results,
    x = ~period,
    y = ~V1,
    name = "ME bp",
    line = list(color = 'rgba(200,100,100,1)')
  )
irf_range_correction %>%
  add_lines(
    data = output_broad_hq_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality",
    line = list(color = 'rgba(300,200,100,1)')
  )
irf_range_correction %>%
  add_lines(
    data = output_broad_hq_2_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without top_5_or_tier)",
    line = list(color = 'rgba(400,200,300,1)')
  )
irf_range_correction %>%
  add_lines(
    data = output_broad_hq_3_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without pub_year_0)",
    line = list(color = 'rgba(500,300,400,1)')
  )
irf_range_correction %>%
  add_lines(
    data = output_broad_hq_4_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (only with no_hf_no_nr)",
    line = list(color = 'rgba(600,100,700,1)')
  )

irf_range_correction %>%
  add_lines(
    data = output_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) %>%
  add_lines(
    data = output_me_bp_results,
    x = ~period,
    y = ~V1,
    name = "ME bp",
    line = list(color = 'rgba(200,100,100,1)')
  ) %>%
  add_lines(
    data = output_broad_hq_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality",
    line = list(color = 'rgba(300,200,100,1)')
  ) %>%
  add_lines(
    data = output_broad_hq_2_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without top_5_or_tier)",
    line = list(color = 'rgba(400,200,300,1)')
  ) %>%
  add_lines(
    data = output_broad_hq_3_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without pub_year_0)",
    line = list(color = 'rgba(500,300,400,1)')
  )  %>%
  add_lines(
    data = output_broad_hq_4_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (only with no_hf_no_nr)",
    line = list(color = 'rgba(600,100,700,1)')
  )

```

### Without sampling 

::: {.callout-warning}

This version has stable results but estimation takes very long. Estimation is deactivated to prevent the document from rendering forever. Activate if you want to see results (we might then store them). 

:::

## Price level

### With sampling

::: {.callout-warning}

This version has unstable results due to drawing samples but much faster estimation.

:::

```{r pricelevel_irf_correction_range}

# Filter the data
out_var <- "inflation"
filtered_data <- data %>%
  filter(!quality_concern, period.month %in% seq(0,60, by = 3), outcome == out_var)#, us==1


# Set up winsorization levels for estimations
wins_para_levels <- c(0,0.01, 0.02, 0.03, 0.04)
conf_lev <- 0.89

# Function to perform meta-analysis for a given wins level
perform_meta_analysis <- function(data, wins) {
  list(
    peese = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      ap = FALSE,
      prec_weighted = TRUE,
      estimation = "PEESE",
      cluster_se = TRUE
    ),
    waap = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      ap = TRUE,
      prec_weighted = FALSE,
      estimation = "UWLS",
      cluster_se = TRUE
      ),
    AK = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      prec_weighted = FALSE,
      estimation = "AK",
      cluster_se = TRUE,
      cutoff_val=1,
      AK_modelmu = "t",
      AK_symmetric = FALSE,
      AK_conf_level = 0.68
  )
  )
}


# Function to extract intercepts
extract_intercepts <- function(model, method) {
  if (method == "AK") {
    estimate <- model$tidy[1, 2]
    se <- model$tidy[1, 3]
    ci_lower <- estimate - se * qnorm(1 - (1 - conf_lev) / 2)
    ci_upper <- estimate + se * qnorm(1 - (1 - conf_lev) / 2)
  } else {
    ci <- confint(model, level = conf_lev)
    estimate <- unname(coef(model)[1])
    ci_lower <- unname(ci[1, 1])
    ci_upper <- unname(ci[1, 2])
  }
  return(c(estimate = estimate, lower = ci_lower, upper = ci_upper))
}


# Function to combine results
combine_results <- function(results_list, method_name) {
  lapply(names(results_list), function(wins_name) {
    results <- results_list[[wins_name]][[method_name]]
    intercepts <- lapply(results, extract_intercepts, method = method_name)
    df <- do.call(rbind, intercepts)
    df <- as.data.frame(df)
    df$period <- as.numeric(rownames(df))
    df$wins_para <- wins_name
    df$method <- method_name
    return(df)
  })
}


analyze_subsample <- function(subsample_id) {#, us_value, group_value
  # Filter data based on 'us' and 'group_ident_broad' values
  subsample <- filtered_data %>%
    #filter(us == us_value, group_ident_broad != group_value) %>%
    group_by(key, period.month) %>%
    sample_n(size = 1, replace = FALSE) %>%
    ungroup()  # Adjust sample size as needed
  
  results_list <- lapply(wins_para_levels, function(wins) perform_meta_analysis(subsample, wins))
  names(results_list) <- paste0("wins_", wins_para_levels)
  
  # Combine results for all methods
  final_peese <- do.call(rbind, combine_results(results_list, "peese"))
  final_waap <- do.call(rbind, combine_results(results_list, "waap"))
  final_ak <- do.call(rbind, combine_results(results_list, "AK"))
  
  # Combine all method results into a single final data frame
  final_df <- rbind(final_peese, final_waap, final_ak)
  final_df$subsample <- subsample_id
  # final_df$us <- us_value
  # final_df$group_ident_broad <- group_value
  
  return(final_df)
}

# Initialize a list to store results
all_results <- list()

# Compute results using the functions from above
results <- lapply(1:10, analyze_subsample)
  

# Combine results for all subsamples
all_results_df <- do.call(rbind, results)

# Use 95%  region of estimate per period. 
min_max_per_period <- all_results_df %>%
  group_by(period) %>%
  summarise(
    min_estimate = quantile(estimate,0.025, na.rm = TRUE),
    max_estimate = quantile(estimate,0.975, na.rm = TRUE)
  ) %>% ungroup()


# Generate the average IRF plot with PEESE correction
irf_range_correction <- plot_average_irfs(
  filtered_data,
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = T
)  %>%
  add_ribbons(
    data = min_max_per_period,
    x = ~period,
    ymin = ~min_estimate,
    ymax = ~max_estimate,
    name = "P-bias correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(100,20,200,0.2)'
  ) %>%
  layout(
    title = "pricelevel response to 100 bp rate shock, average and p-bias corrected range",
    xaxis = list(title = "Month"),
    yaxis = list(title = "Effect in %"),
    hovermode = "compare"
  )

irf_range_correction

irf_range_correction %>%
  add_lines(
    data = pricelevel_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  )
irf_range_correction %>%
  add_lines(
    data = pricelevel_me_bp_results,
    x = ~period,
    y = ~V1,
    name = "ME bp",
    line = list(color = 'rgba(200,100,100,1)')
  )
irf_range_correction %>%
  add_lines(
    data = pricelevel_broad_hq_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality",
    line = list(color = 'rgba(300,200,100,1)')
  )
irf_range_correction %>%
  add_lines(
    data = pricelevel_broad_hq_2_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without top_5_or_tier)",
    line = list(color = 'rgba(400,200,300,1)')
  )
irf_range_correction %>%
  add_lines(
    data = pricelevel_broad_hq_3_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without pub_year_0)",
    line = list(color = 'rgba(500,300,400,1)')
  )
irf_range_correction %>%
  add_lines(
    data = pricelevel_broad_hq_4_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (only with no_hf_no_nr)",
    line = list(color = 'rgba(600,100,700,1)')
  )

irf_range_correction %>%
  add_lines(
    data = pricelevel_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) %>%
  add_lines(
    data = pricelevel_me_bp_results,
    x = ~period,
    y = ~V1,
    name = "ME bp",
    line = list(color = 'rgba(200,100,100,1)')
  ) %>%
  add_lines(
    data = pricelevel_broad_hq_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality",
    line = list(color = 'rgba(300,200,100,1)')
  ) %>%
  add_lines(
    data = pricelevel_broad_hq_2_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without top_5_or_tier)",
    line = list(color = 'rgba(400,200,300,1)')
  ) %>%
  add_lines(
    data = pricelevel_broad_hq_3_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without pub_year_0)",
    line = list(color = 'rgba(500,300,400,1)')
  )  %>%
  add_lines(
    data = pricelevel_broad_hq_4_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (only with no_hf_no_nr)",
    line = list(color = 'rgba(600,100,700,1)')
  )

```

### Without sampling 

::: {.callout-warning}

This version has stable results but estimation takes very long. Estimation is deactivated to prevent the document from rendering forever. Activate if you want to see results (we might then store them). 

:::

## Unemployment rate

## Employment 

## Interest rate

::: {.callout-important}

Failed to run for rate. Try again.

:::

### With sampling

::: {.callout-warning}

This version has unstable results due to drawing samples but much faster estimation.

:::

```{r rate_irf_correction_range}
#| eval: false

# Filter the data
out_var <- "rate"
filtered_data <- data %>%
  filter(!quality_concern, period.month %in% seq(0,60, by = 3), outcome == out_var)#, us==1


# Set up winsorization levels for estimations
wins_para_levels <- c(0,0.01, 0.02, 0.03, 0.04)
conf_lev <- 0.89

# Function to perform meta-analysis for a given wins level
perform_meta_analysis <- function(data, wins) {
  list(
    peese = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      ap = FALSE,
      prec_weighted = TRUE,
      estimation = "PEESE",
      cluster_se = TRUE
    ),
    waap = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      ap = TRUE,
      prec_weighted = FALSE,
      estimation = "UWLS",
      cluster_se = TRUE
      ),
    AK = meta_analysis(
      data = data,
      outvar = out_var,
      se_option = "avg",
      periods = chosen_periods,
      wins = wins,
      prec_weighted = FALSE,
      estimation = "AK",
      cluster_se = TRUE,
      cutoff_val=1,
      AK_modelmu = "t",
      AK_symmetric = FALSE,
      AK_conf_level = 0.68
  )
  )
}


# Function to extract intercepts
extract_intercepts <- function(model, method) {
  if (method == "AK") {
    estimate <- model$tidy[1, 2]
    se <- model$tidy[1, 3]
    ci_lower <- estimate - se * qnorm(1 - (1 - conf_lev) / 2)
    ci_upper <- estimate + se * qnorm(1 - (1 - conf_lev) / 2)
  } else {
    ci <- confint(model, level = conf_lev)
    estimate <- unname(coef(model)[1])
    ci_lower <- unname(ci[1, 1])
    ci_upper <- unname(ci[1, 2])
  }
  return(c(estimate = estimate, lower = ci_lower, upper = ci_upper))
}


# Function to combine results
combine_results <- function(results_list, method_name) {
  lapply(names(results_list), function(wins_name) {
    results <- results_list[[wins_name]][[method_name]]
    intercepts <- lapply(results, extract_intercepts, method = method_name)
    df <- do.call(rbind, intercepts)
    df <- as.data.frame(df)
    df$period <- as.numeric(rownames(df))
    df$wins_para <- wins_name
    df$method <- method_name
    return(df)
  })
}


analyze_subsample <- function(subsample_id) {#, us_value, group_value
  # Filter data based on 'us' and 'group_ident_broad' values
  subsample <- filtered_data %>%
    #filter(us == us_value, group_ident_broad != group_value) %>%
    group_by(key, period.month) %>%
    sample_n(size = 1, replace = FALSE) %>%
    ungroup()  # Adjust sample size as needed
  
  results_list <- lapply(wins_para_levels, function(wins) perform_meta_analysis(subsample, wins))
  names(results_list) <- paste0("wins_", wins_para_levels)
  
  # Combine results for all methods
  final_peese <- do.call(rbind, combine_results(results_list, "peese"))
  final_waap <- do.call(rbind, combine_results(results_list, "waap"))
  final_ak <- do.call(rbind, combine_results(results_list, "AK"))
  
  # Combine all method results into a single final data frame
  final_df <- rbind(final_peese, final_waap, final_ak)
  final_df$subsample <- subsample_id
  # final_df$us <- us_value
  # final_df$group_ident_broad <- group_value
  
  return(final_df)
}

# Initialize a list to store results
all_results <- list()

# Compute results using the functions from above
results <- lapply(1:10, analyze_subsample)
  

# Combine results for all subsamples
all_results_df <- do.call(rbind, results)

# Use 95%  region of estimate per period. 
min_max_per_period <- all_results_df %>%
  group_by(period) %>%
  summarise(
    min_estimate = quantile(estimate,0.025, na.rm = TRUE),
    max_estimate = quantile(estimate,0.975, na.rm = TRUE)
  ) %>% ungroup()


# Generate the average IRF plot with PEESE correction
irf_range_correction <- plot_average_irfs(
  filtered_data,
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = T
)  %>%
  add_ribbons(
    data = min_max_per_period,
    x = ~period,
    ymin = ~min_estimate,
    ymax = ~max_estimate,
    name = "P-bias correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(100,20,200,0.2)'
  ) %>%
  layout(
    title = "rate response to 100 bp rate shock, average and p-bias corrected range",
    xaxis = list(title = "Month"),
    yaxis = list(title = "Effect in %"),
    hovermode = "compare"
  ) %>%
  add_lines(
    data = rate_cons_hq_results,
    x = ~period,
    y = ~V1,
    name = "Conservative high quality",
    line = list(color = 'rgba(100,100,100,1)')
  ) %>%
  add_lines(
    data = rate_me_bp_results,
    x = ~period,
    y = ~V1,
    name = "ME bp",
    line = list(color = 'rgba(200,100,100,1)')
  ) %>%
  add_lines(
    data = rate_broad_hq_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality",
    line = list(color = 'rgba(300,200,100,1)')
  ) %>%
  add_lines(
    data = rate_broad_hq_2_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without top_5_or_tier)",
    line = list(color = 'rgba(400,200,300,1)')
  ) %>%
  add_lines(
    data = rate_broad_hq_3_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (without pub_year_0)",
    line = list(color = 'rgba(500,300,400,1)')
  )  %>%
  add_lines(
    data = rate_broad_hq_4_results,
    x = ~period,
    y = ~V1,
    name = "Broad high quality (only with no_hf_no_nr)",
    line = list(color = 'rgba(600,100,700,1)')
  )

irf_range_correction
```

### Without sampling 

::: {.callout-warning}

This version has stable results but estimation takes very long. Estimation is deactivated to prevent the document from rendering forever. Activate if you want to see results (we might then store them). 

:::


# Country and country group analysis

## Average and PEESE-corrected IRFs

### Output 

```{r avg_irf_output_countries}

out_var <- "output"

# PEESE estimation for subsamples
# US
peese_results_output_us <- meta_analysis(
  data = data %>% filter(us == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# EA12
peese_results_output_ea12 <- meta_analysis(
  data = data %>% filter(ea12 == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# Upper middle
peese_results_output_upper_middle <- meta_analysis(
  data = data %>% filter(upper_middle == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# Other advanced 
peese_results_output_other_advanced <- meta_analysis(
  data = data %>% filter(advanced == 1, ea12 != 1, us != 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)


# Extract intercept estimates (corrected IRF)
extract_intercepts <- function(results) {
  intercepts <- lapply(results, function(model) {
    ci <- confint(model, level = 0.89)  # Using 89% confidence interval as in the app
    c(estimate = unname(coef(model)[1]),
      lower = ci[1, 1],
      upper = ci[1, 2])
  })
  
  data.frame(
    period = as.numeric(names(results)),
    estimate = sapply(intercepts, function(x) x["estimate"]),
    lower = sapply(intercepts, function(x) x["lower"]),
    upper = sapply(intercepts, function(x) x["upper"])
  )
}

# Extract corrected effects for subsamples
corrected_irf_peese_output_us <- extract_intercepts(peese_results_output_us)
corrected_irf_peese_output_ea12 <- extract_intercepts(peese_results_output_ea12)
corrected_irf_peese_output_em <- extract_intercepts(peese_results_output_upper_middle)
corrected_irf_peese_output_otheradv <- extract_intercepts(peese_results_output_other_advanced)

# IRFs 
# US
avg_irf_output_us <- plot_average_irfs(
  data %>% filter(us == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_output_us,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_output_us,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# EA12
avg_irf_output_ea12 <- plot_average_irfs(
  data %>% filter(ea12 == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_output_ea12,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_output_ea12,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# Upper middle
avg_irf_output_upper_middle <- plot_average_irfs(
  data %>% filter(upper_middle == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_output_em,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_output_em,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# Other advanced 
avg_irf_output_other_advanced <- plot_average_irfs(
  data %>% filter(advanced == 1, ea12 != 1, us != 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_output_otheradv,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_output_otheradv,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

#### Create overall plot
subplot(avg_irf_output_us, avg_irf_output_ea12, avg_irf_output_upper_middle, avg_irf_output_other_advanced, nrows = 2, margin = 0.04) %>% layout(
  showlegend = F,
  title = 'Output response to 100 bp rate shock, average and p-bias corrected IRFs',
  yaxis = list(title = "Effect"),
  xaxis3 = list(title = "Month"),
  yaxis3 = list(title = "Effect in %"), # y-axis for plot 3 ####### adjsut to p.p. for rate response
  xaxis4 = list(title = "Month")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.2, y = 1, text = "US", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.8, y = 1, text = "Euro Area", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.2, y = 0.45, text = "Emerging Economies", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.8, y = 0.45, text = "Other Advanced", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16))
),
margin = list(t = 80))

```


### Price level 

```{r avg_irf_pricelevel_countries}

out_var <- "inflation"

# PEESE estimation for subsamples
# US
peese_results_pricelevel_us <- meta_analysis(
  data = data %>% filter(us == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# EA12
peese_results_pricelevel_ea12 <- meta_analysis(
  data = data %>% filter(ea12 == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# Upper middle
peese_results_pricelevel_upper_middle <- meta_analysis(
  data = data %>% filter(upper_middle == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# Other advanced 
peese_results_pricelevel_other_advanced <- meta_analysis(
  data = data %>% filter(advanced == 1, ea12 != 1, us != 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)


# Extract intercept estimates (corrected IRF)
extract_intercepts <- function(results) {
  intercepts <- lapply(results, function(model) {
    ci <- confint(model, level = 0.89)  # Using 89% confidence interval as in the app
    c(estimate = unname(coef(model)[1]),
      lower = ci[1, 1],
      upper = ci[1, 2])
  })
  
  data.frame(
    period = as.numeric(names(results)),
    estimate = sapply(intercepts, function(x) x["estimate"]),
    lower = sapply(intercepts, function(x) x["lower"]),
    upper = sapply(intercepts, function(x) x["upper"])
  )
}

# Extract corrected effects for subsamples
corrected_irf_peese_pricelevel_us <- extract_intercepts(peese_results_pricelevel_us)
corrected_irf_peese_pricelevel_ea12 <- extract_intercepts(peese_results_pricelevel_ea12)
corrected_irf_peese_pricelevel_em <- extract_intercepts(peese_results_pricelevel_upper_middle)
corrected_irf_peese_pricelevel_otheradv <- extract_intercepts(peese_results_pricelevel_other_advanced)

# IRFs 
# US
avg_irf_pricelevel_us <- plot_average_irfs(
  data %>% filter(us == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_pricelevel_us,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_pricelevel_us,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# EA12
avg_irf_pricelevel_ea12 <- plot_average_irfs(
  data %>% filter(ea12 == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_pricelevel_ea12,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_pricelevel_ea12,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# Upper middle
avg_irf_pricelevel_upper_middle <- plot_average_irfs(
  data %>% filter(upper_middle == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_pricelevel_em,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_pricelevel_em,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# Other advanced 
avg_irf_pricelevel_other_advanced <- plot_average_irfs(
  data %>% filter(advanced == 1, ea12 != 1, us != 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_pricelevel_otheradv,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_pricelevel_otheradv,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

#### Create overall plot
subplot(avg_irf_pricelevel_us, avg_irf_pricelevel_ea12, avg_irf_pricelevel_upper_middle, avg_irf_pricelevel_other_advanced, nrows = 2, margin = 0.04) %>% layout(
  showlegend = F,
  title = 'pricelevel response to 100 bp rate shock, average and p-bias corrected IRFs',
  yaxis = list(title = "Effect"),
  xaxis3 = list(title = "Month"),
  yaxis3 = list(title = "Effect in %"), # y-axis for plot 3 ####### adjsut to p.p. for rate response
  xaxis4 = list(title = "Month")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.2, y = 1, text = "US", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.8, y = 1, text = "Euro Area", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.2, y = 0.45, text = "Emerging Economies", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.8, y = 0.45, text = "Other Advanced", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16))
),
margin = list(t = 80))

```


### Interest rate

```{r avg_irf_rate_countries}

out_var <- "rate"

# PEESE estimation for subsamples
# US
peese_results_rate_us <- meta_analysis(
  data = data %>% filter(us == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# EA12
peese_results_rate_ea12 <- meta_analysis(
  data = data %>% filter(ea12 == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# Upper middle
peese_results_rate_upper_middle <- meta_analysis(
  data = data %>% filter(upper_middle == 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)
# Other advanced 
peese_results_rate_other_advanced <- meta_analysis(
  data = data %>% filter(advanced == 1, ea12 != 1, us != 1),
  outvar = out_var,
  se_option = "avg",
  periods = chosen_periods,
  wins = wins_para,
  ap = FALSE,
  prec_weighted = TRUE,
  estimation = "PEESE",
  cluster_se = TRUE
)


# Extract intercept estimates (corrected IRF)
extract_intercepts <- function(results) {
  intercepts <- lapply(results, function(model) {
    ci <- confint(model, level = 0.89)  # Using 89% confidence interval as in the app
    c(estimate = unname(coef(model)[1]),
      lower = ci[1, 1],
      upper = ci[1, 2])
  })
  
  data.frame(
    period = as.numeric(names(results)),
    estimate = sapply(intercepts, function(x) x["estimate"]),
    lower = sapply(intercepts, function(x) x["lower"]),
    upper = sapply(intercepts, function(x) x["upper"])
  )
}

# Extract corrected effects for subsamples
corrected_irf_peese_rate_us <- extract_intercepts(peese_results_rate_us)
corrected_irf_peese_rate_ea12 <- extract_intercepts(peese_results_rate_ea12)
corrected_irf_peese_rate_em <- extract_intercepts(peese_results_rate_upper_middle)
corrected_irf_peese_rate_otheradv <- extract_intercepts(peese_results_rate_other_advanced)

# IRFs 
# US
avg_irf_rate_us <- plot_average_irfs(
  data %>% filter(us == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_rate_us,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_rate_us,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# EA12
avg_irf_rate_ea12 <- plot_average_irfs(
  data %>% filter(ea12 == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_rate_ea12,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_rate_ea12,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# Upper middle
avg_irf_rate_upper_middle <- plot_average_irfs(
  data %>% filter(upper_middle == 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_rate_em,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_rate_em,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

# Other advanced 
avg_irf_rate_other_advanced <- plot_average_irfs(
  data %>% filter(advanced == 1, ea12 != 1, us != 1, period.month %in% seq(0,60,by=3), outcome == out_var),
  period_limit = 60,
  winsor = TRUE,
  wins_par = wins_para,
  corrected_irf = NULL,
  show_legend = TRUE
) %>%
  add_ribbons(
    data = corrected_irf_peese_rate_otheradv,
    x = ~period,
    ymin = ~lower,
    ymax = ~upper,
    name = "PEESE correction",
    line = list(color = 'rgba(0,0,0,0)'),
    fillcolor = 'rgba(255,0,0,0.2)'
  ) %>%
  add_lines(
    data = corrected_irf_peese_rate_otheradv,
    x = ~period,
    y = ~estimate,
    name = "PEESE correction Mean",
    line = list(color = 'rgba(100,20,200,0.2)')
  )

#### Create overall plot
subplot(avg_irf_rate_us, avg_irf_rate_ea12, avg_irf_rate_upper_middle, avg_irf_rate_other_advanced, nrows = 2, margin = 0.04) %>% layout(
  showlegend = F,
  title = 'rate response to 100 bp rate shock, average and p-bias corrected IRFs',
  yaxis = list(title = "Effect"),
  xaxis3 = list(title = "Month"),
  yaxis3 = list(title = "Effect in %"), # y-axis for plot 3 ####### adjsut to p.p. for rate response
  xaxis4 = list(title = "Month")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.2, y = 1, text = "US", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.8, y = 1, text = "Euro Area", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.2, y = 0.45, text = "Emerging Economies", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16)),
  list(x = 0.8, y = 0.45, text = "Other Advanced", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom", font = list(size = 16))
),
margin = list(t = 80))

```

# Outputs for Working Papers

::: {.callout-note}
## Discuss

### Brodeur plots 

```{r}
# Output

################## compare SE.avg vs SE.upper ##################
brodeur_dens_3_12_24_36_output_avg
brodeur_dens_3_12_24_36_output
brodeur_dens_all_periods_output_avg
brodeur_dens_all_periods_output
brodeur_dens_horizons_output_avg
brodeur_dens_horizons_output
brodeur_dens_horizons_top_tier_output_avg
brodeur_dens_horizons_top_tier_output

################## With SE.upper ##################
# Full sample 
brodeur_dens_3_12_24_36_output
brodeur_dens_all_periods_output
brodeur_dens_horizons_output

# Top tier journals
top_tier_journal_share_plot
brodeur_dens_horizons_top_tier_output

################## Other facets ##################


```

```{r}

# Price level

################## compare SE.avg vs SE.upper ##################
brodeur_dens_3_12_24_36_pricelevel_avg
brodeur_dens_3_12_24_36_pricelevel
brodeur_dens_all_periods_pricelevel_avg
brodeur_dens_all_periods_pricelevel
brodeur_dens_horizons_pricelevel_avg
brodeur_dens_horizons_pricelevel
brodeur_dens_horizons_top_tier_pricelevel_avg
brodeur_dens_horizons_top_tier_pricelevel

################## With SE.upper ##################
brodeur_dens_3_12_24_36_pricelevel
brodeur_dens_all_periods_pricelevel
brodeur_dens_horizons_pricelevel

# Top tier journals
top_tier_journal_share_plot
brodeur_dens_horizons_top_tier_pricelevel

################## Other facets ##################


```

```{r}

# Interest rate

################## compare SE.avg vs SE.lower ##################
brodeur_dens_3_12_24_36_rate_avg
brodeur_dens_3_12_24_36_rate
brodeur_dens_all_periods_rate_avg
brodeur_dens_all_periods_rate
brodeur_dens_horizons_rate_avg
brodeur_dens_horizons_rate
brodeur_dens_horizons_top_tier_rate_avg
brodeur_dens_horizons_top_tier_rate

################## With SE.lower ##################
brodeur_dens_3_12_24_36_rate
brodeur_dens_all_periods_rate
brodeur_dens_horizons_rate

# Top tier journals
top_tier_journal_share_plot
brodeur_dens_horizons_top_tier_rate

################## Other facets ##################


```

:::

## Working Paper 1 - "The overstated effects of conventional monetary policy on output and prices"

### Publication Bias

#### Average output and price level response (uncorrected)

```{r WP1_average_irfs_output_pricelevel}

# Create plot 
WP1_average_irfs_output_pricelevel <- subplot(avg_irf_output, avg_irf_pricelevel, nrows = 1, margin = 0.03) %>% layout(
  showlegend=FALSE,
  title = 'Effects of conventional monetary policy shocks',
  xaxis3 = list(title = "Month"), # x-axis for plot 3
  xaxis4 = list(title = "Month")  # x-axis for plot 4
) %>% layout(annotations = list(
  list(x = 0.25, y = 1, text = "Output", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom"),
  list(x = 0.75, y = 1, text = "Price level", showarrow = FALSE, xref = "paper", yref = "paper",
       xanchor = "center", yanchor = "bottom")
),
margin = list(t = 60)) %>%
    layout(
      xaxis = list(title = "Months"),
      xaxis2 = list(title = "Months"),
      yaxis = list(title = "Effect (%)",
                   range = list(-2.8,0.8)
                   ),
      yaxis2 = list(range = list(-2.8,0.8)
                   ),
      hovermode = "compare"
    )

# Display plot
WP1_average_irfs_output_pricelevel

# Save pdf
orca(WP1_average_irfs_output_pricelevel,
      file = "outputs_for_working_papers/wp1/include/uncorrected_average_irfs_output_pricelevel.pdf",
      scale = NULL,
      width = 1500,
      height = NULL
    )

```

#### Brodeur, p-hacking: density plots, distribution of z-statistics: 3 months, 12 months, 24 months, 36 months after the monetary policy shock (ein Plot, 4 sub-figures) - including counterfactual distribution of z-statistics

```{r}

# Output

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_3_12_24_36_output.pdf", brodeur_dens_3_12_24_36_output, width = 6, height = 5)

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_horizons_output.pdf", brodeur_dens_horizons_output, width = 6, height = 5)

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_horizons_top_tier_output.pdf", brodeur_dens_horizons_top_tier_output, width = 6, height = 5)

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_all_periods_output.pdf", brodeur_dens_all_periods_output, width = 20, height = 12)
```

```{r}

# Price level

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_3_12_24_36_pricelevel.pdf", brodeur_dens_3_12_24_36_pricelevel, width = 6, height = 5)

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_horizons_pricelevel.pdf", brodeur_dens_horizons_pricelevel, width = 6, height = 5)

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_horizons_top_tier_pricelevel.pdf", brodeur_dens_horizons_top_tier_pricelevel, width = 6, height = 5)

ggsave("outputs_for_working_papers/wp1/discuss/brodeur_dens_all_periods_pricelevel.pdf", brodeur_dens_all_periods_pricelevel, width = 20, height = 12)
```


#### Randomisation tests (Brodeur et al. 2020; siehe Anhang) to econometrically confirm bunching of estimates at critical thresholds of significance - eventually als Table, aber das können wir wohl auch in den Appendix integrieren.

#### Andrews-Kasy: conditional publication probabilities, 3 months, 12 months, 24 months, 36 months after the monetary policy shock (one plot, sub-figures) - wichtig wäre hier, dass die y-Achse über die sub-figures normalisiert ist, um es einfach ersichtlich zu machen, dass die steps bei späteren Horizonten größer sind.

```{r}
library(patchwork)

# Output 
months <- seq(3, 60, by = 3)
plots <- list()
for (month in months) {
  plot_name <- paste0("p", month)
  plots[[plot_name]] <- output_ak[[as.character(month)]]$plot + 
    theme_minimal() + 
    labs(subtitle = paste("Month", month)) + 
    labs(y = "Pub.Pr.")
}
# All quarters
combined_plot_all <- plots$p3 + plots$p6  + plots$p9 + plots$p12 + plots$p15  + plots$p18 + plots$p21 + plots$p24 + plots$p27 + plots$p30 + plots$p33 + plots$p36 + plots$p39 + plots$p42 + plots$p45 + plots$p48 + plots$p51  + plots$p54  + plots$p57 +plots$p60 + 
  # plot_layout(ncol = 4, byrow = TRUE) # Alternative layout
  plot_layout(nrow = 1, byrow = TRUE) # As one row
combined_plot_all
# Every two quarters up to 4 years
combined_plot_two_quarters <- plots$p6 + plots$p12+ plots$p18+ plots$p24+ plots$p30+ plots$p36 + plots$p42 + plots$p48 +
  plot_layout(ncol = 4, byrow = TRUE) # Alternative layout
  # plot_layout(nrow = 1, byrow = TRUE) # As one row
combined_plot_two_quarters
# Very few periods
combined_plot_years <- plots$p3 + plots$p12 + plots$p24 + plots$p36 + plots$p48 + #plots$p60 +
  # plot_layout(nrow = 4, byrow = TRUE) # Alternative layout
  plot_layout(nrow = 1, byrow = TRUE) # As one row
combined_plot_years

ggsave("outputs_for_working_papers/wp1/discuss/publication_prob_years_output.pdf", combined_plot_years, width = 12, height = 4)


# Price level 
months <- seq(3, 60, by = 3)
plots <- list()
for (month in months) {
  plot_name <- paste0("p", month)
  plots[[plot_name]] <- pricelevel_ak[[as.character(month)]]$plot + 
    theme_minimal() + 
    labs(subtitle = paste("Month", month)) + 
    labs(y = "Pub.Pr.")
}
# All quarters
combined_plot_all <- plots$p3 + plots$p6  + plots$p9 + plots$p12 + plots$p15  + plots$p18 + plots$p21 + plots$p24 + plots$p27 + plots$p30 + plots$p33 + plots$p36 + plots$p39 + plots$p42 + plots$p45 + plots$p48 + plots$p51  + plots$p54  + plots$p57 +plots$p60 + 
  # plot_layout(ncol = 4, byrow = TRUE) # Alternative layout
  plot_layout(nrow = 1, byrow = TRUE) # As one row
combined_plot_all
# Every two quarters up to 4 years
combined_plot_two_quarters <- plots$p6 + plots$p12+ plots$p18+ plots$p24+ plots$p30+ plots$p36 + plots$p42 + plots$p48 +
  plot_layout(ncol = 4, byrow = TRUE) # Alternative layout
  # plot_layout(nrow = 1, byrow = TRUE) # As one row
combined_plot_two_quarters
# Very few periods
combined_plot_years <- plots$p3 + plots$p12 + plots$p24 + plots$p36 + plots$p48 + #plots$p60 +
  # plot_layout(nrow = 4, byrow = TRUE) # Alternative layout
  plot_layout(nrow = 1, byrow = TRUE) # As one row
combined_plot_years

ggsave("outputs_for_working_papers/wp1/discuss/publication_prob_years_pricelevel.pdf", combined_plot_years, width = 12, height = 4)



```



#### Funnel plots: 3 months, 12 months, 24 months, 36 months after the monetary policy shock

##### Output 
```{r WP1_funnel_output}

out_var <- "output"
periods <- c(3, 12, 24, 36)

# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     se_option = "avg",
                     legend = FALSE,
                     wins = wins_para,
                     opac = 0.04,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
WP1_funnel_output <- subplot(plot_list, nrows = 4, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "")

# Display the subplot
WP1_funnel_output

# Save pdf
orca(WP1_funnel_output,
      file = "outputs_for_working_papers/wp1/include/funnel_plots/funnel_output.pdf",
      scale = NULL,
      width = 800,
      height = 1000
    )

```

##### Price level 

```{r WP1_funnel_pricelevel}

out_var <- "inflation"

# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     se_option = "avg",
                     legend = FALSE,
                     wins = wins_para,
                     opac = 0.04,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
WP1_funnel_pricelevel <- subplot(plot_list, nrows = 4, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "")

# Display the subplot
WP1_funnel_pricelevel

# Save pdf
orca(WP1_funnel_pricelevel,
      file = "outputs_for_working_papers/wp1/include/funnel_plots/funnel_pricelevel.pdf",
      scale = NULL,
      width = 800,
      height = 1000
    )

```
##### Interest rate
```{r WP1_funnel_rate}

out_var <- "rate"

# Create a list of plots
plot_list <- lapply(periods, function(prd) {
  p <- create_funnel_plot(data %>% filter(outcome == out_var),
                     outvar = out_var,
                     prd = prd,
                     se_option = "avg",
                     legend = FALSE,
                     wins = wins_para,
                     opac = 0.04,
                     ap = FALSE,
                     type = "standard")
  # Add annotation for period
  p <- p %>% add_annotations(
    text = paste("Period", prd),
    x = 0.5,
    y = 1,
    xref = "paper",
    yref = "paper",
    xanchor = "center",
    yanchor = "bottom",
    showarrow = FALSE,
    font = list(size = 14)
  )
  
  return(p)
})


# Combine plots into a subplot
WP1_funnel_rate <- subplot(plot_list, nrows = 4, shareX = TRUE, shareY = TRUE) %>%
  layout(title = "")

# Display the subplot
WP1_funnel_rate

# Save pdf
orca(WP1_funnel_rate,
      file = "outputs_for_working_papers/wp1/include/funnel_plots/funnel_rate.pdf",
      scale = NULL,
      width = 800,
      height = 1000
    )

```

#### IRFs with range of publication bias corrected estimates - drei sub-figures zu output, price level und interest rate response in einem Plot



